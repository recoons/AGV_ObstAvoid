/*
 This is public domain software, however it is preferred
 that the following disclaimers be attached.

 Software Copywrite/Warranty Disclaimer

 This software was developed at the National Institute of Standards and
 Technology by employees of the Federal Government in the course of their
 official duties. Pursuant to title 17 Section 105 of the United States
 Code this software is not subject to copyright protection and is in the
 public domain. This software is experimental. NIST assumes no responsibility
 whatsoever for its use by other parties, and makes no guarantees, expressed
 or implied, aboutc its quality, reliability, or any other characteristic.

 We would appreciate acknowledgement if the software is used. This software can
 be redistributed and/or modified freely provided that any derivative works
 bear some notice that they are derived from it, and any modified
 versions bear some notice that they have been modified.

 */
package splinetest;

import java.awt.Component;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.Rectangle2D;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.StringReader;
import java.lang.reflect.Method;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.text.DateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JViewport;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 * Main JFrame for containing components that display/draw/select objects in the
 * 2D world include vehicles, obstacles, boundaries and planned splines.
 *
 * @author Will Shackleford<shackle@nist.gov>
 */
public class SplineTestJFrame extends javax.swing.JFrame {

    /**
     * Creates new form SplineTestJFrame
     */
    public SplineTestJFrame() {
        initComponents();
        this.centerDrawPanelViewPort();
        this.loadRecentFiles();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroupDrawMode = new javax.swing.ButtonGroup();
        jSeparator3 = new javax.swing.JSeparator();
        jScrollPane1 = new javax.swing.JScrollPane();
        splinePanel1 = new splinetest.SplinePanel();
        jToolBar1 = new javax.swing.JToolBar();
        jButtonClear = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JToolBar.Separator();
        jRadioButtonStart = new javax.swing.JRadioButton();
        jRadioButtonGoal = new javax.swing.JRadioButton();
        jRadioButtonObstacle = new javax.swing.JRadioButton();
        jRadioButtonSelect = new javax.swing.JRadioButton();
        jRadioButtonBoundary = new javax.swing.JRadioButton();
        jRadioButtonHorzBoundary = new javax.swing.JRadioButton();
        jRadioButtonVertBoundary = new javax.swing.JRadioButton();
        jRadioButtonPan = new javax.swing.JRadioButton();
        jSeparator2 = new javax.swing.JToolBar.Separator();
        jButtonZoomMore = new javax.swing.JButton();
        jButtonZoomLess = new javax.swing.JButton();
        jButtonFit = new javax.swing.JButton();
        jButtonDelete = new javax.swing.JButton();
        jToolBar2 = new javax.swing.JToolBar();
        jCheckBoxShowPlanning = new javax.swing.JCheckBox();
        jCheckBoxCrab = new javax.swing.JCheckBox();
        jCheckBoxReverse = new javax.swing.JCheckBox();
        jCheckBoxShowOutlines = new javax.swing.JCheckBox();
        jCheckBoxShowPlanOutline = new javax.swing.JCheckBox();
        jCheckBoxShowControlPath = new javax.swing.JCheckBox();
        jCheckBoxLabelControlPoints = new javax.swing.JCheckBox();
        jCheckBoxShowGrid = new javax.swing.JCheckBox();
        jCheckBoxLabelGrid = new javax.swing.JCheckBox();
        jCheckBoxSimulation = new javax.swing.JCheckBox();
        jCheckBoxShowSideCurves = new javax.swing.JCheckBox();
        jCheckBoxShowCenterCurve = new javax.swing.JCheckBox();
        jCheckBoxExclusiveTracks = new javax.swing.JCheckBox();
        jLabelStatus = new javax.swing.JLabel();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItemFileSaveAs = new javax.swing.JMenuItem();
        jMenuItemFileOpen = new javax.swing.JMenuItem();
        jMenuRecentFiles = new javax.swing.JMenu();
        jMenuImport = new javax.swing.JMenu();
        jMenuItemImportDXFBackground = new javax.swing.JMenuItem();
        jMenuItemImportDXFBoundaries = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenuItemClear = new javax.swing.JMenuItem();
        jMenuItemChangeFields = new javax.swing.JMenuItem();
        jMenuItemSetProperty = new javax.swing.JMenuItem();
        jMenuItemDelete = new javax.swing.JMenuItem();
        jMenuMove = new javax.swing.JMenu();
        jMenuItemUp = new javax.swing.JMenuItem();
        jMenuItemDown = new javax.swing.JMenuItem();
        jMenuItemLeft = new javax.swing.JMenuItem();
        jMenuItemRight = new javax.swing.JMenuItem();
        jMenuConnections = new javax.swing.JMenu();
        jCheckBoxMenuItemConnectedToVehicle = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemDebugVehicleComm = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemConnectToObsDetect = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemDebugObsDetComm = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemConnectToVehicleManual = new javax.swing.JCheckBoxMenuItem();
        jMenuChecks = new javax.swing.JMenu();
        jMenuItemReCheckPath = new javax.swing.JMenuItem();
        jMenuItemForceReplanning = new javax.swing.JMenuItem();
        jCheckBoxMenuItemReplanOnAllChanges = new javax.swing.JCheckBoxMenuItem();
        jMenuItemSwapGoalStart = new javax.swing.JMenuItem();
        jMenuItemPlotLastCntrlPtsSent = new javax.swing.JMenuItem();
        jCheckBoxMenuItemPlotAllCntlrPts = new javax.swing.JCheckBoxMenuItem();
        jMenuBackground = new javax.swing.JMenu();
        jCheckBoxMenuItemShowBackground = new javax.swing.JCheckBoxMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("AGV Obstacle Avoidance Spline Planning");
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });
        addWindowStateListener(new java.awt.event.WindowStateListener() {
            public void windowStateChanged(java.awt.event.WindowEvent evt) {
                formWindowStateChanged(evt);
            }
        });

        splinePanel1.setPreferredSize(new java.awt.Dimension(2000, 2000));

        javax.swing.GroupLayout splinePanel1Layout = new javax.swing.GroupLayout(splinePanel1);
        splinePanel1.setLayout(splinePanel1Layout);
        splinePanel1Layout.setHorizontalGroup(
            splinePanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2000, Short.MAX_VALUE)
        );
        splinePanel1Layout.setVerticalGroup(
            splinePanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2000, Short.MAX_VALUE)
        );

        jScrollPane1.setViewportView(splinePanel1);

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        jButtonClear.setText("Clear");
        jButtonClear.setFocusable(false);
        jButtonClear.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonClear.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonClear);
        jToolBar1.add(jSeparator1);

        buttonGroupDrawMode.add(jRadioButtonStart);
        jRadioButtonStart.setSelected(true);
        jRadioButtonStart.setText(" Start ");
        jRadioButtonStart.setFocusable(false);
        jRadioButtonStart.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonStart.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonStartActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonStart);

        buttonGroupDrawMode.add(jRadioButtonGoal);
        jRadioButtonGoal.setText(" Goal ");
        jRadioButtonGoal.setFocusable(false);
        jRadioButtonGoal.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonGoal.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonGoal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonGoalActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonGoal);

        buttonGroupDrawMode.add(jRadioButtonObstacle);
        jRadioButtonObstacle.setText(" Obstacle ");
        jRadioButtonObstacle.setFocusable(false);
        jRadioButtonObstacle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonObstacle.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonObstacle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonObstacleActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonObstacle);

        buttonGroupDrawMode.add(jRadioButtonSelect);
        jRadioButtonSelect.setText(" Select ");
        jRadioButtonSelect.setFocusable(false);
        jRadioButtonSelect.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonSelect.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonSelect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonSelectActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonSelect);

        buttonGroupDrawMode.add(jRadioButtonBoundary);
        jRadioButtonBoundary.setText(" Boundary ");
        jRadioButtonBoundary.setFocusable(false);
        jRadioButtonBoundary.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonBoundary.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonBoundary.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonBoundaryActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonBoundary);

        buttonGroupDrawMode.add(jRadioButtonHorzBoundary);
        jRadioButtonHorzBoundary.setText(" Horz. Boundary ");
        jRadioButtonHorzBoundary.setFocusable(false);
        jRadioButtonHorzBoundary.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonHorzBoundary.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonHorzBoundary.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonHorzBoundaryActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonHorzBoundary);

        buttonGroupDrawMode.add(jRadioButtonVertBoundary);
        jRadioButtonVertBoundary.setText(" Vert. Boundary ");
        jRadioButtonVertBoundary.setFocusable(false);
        jRadioButtonVertBoundary.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonVertBoundary.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonVertBoundary.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonVertBoundaryActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonVertBoundary);

        buttonGroupDrawMode.add(jRadioButtonPan);
        jRadioButtonPan.setText(" Pan ");
        jRadioButtonPan.setFocusable(false);
        jRadioButtonPan.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonPan.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonPan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonPanActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonPan);
        jToolBar1.add(jSeparator2);

        jButtonZoomMore.setText(" Zoom + ");
        jButtonZoomMore.setFocusable(false);
        jButtonZoomMore.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonZoomMore.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonZoomMore.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonZoomMoreActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonZoomMore);

        jButtonZoomLess.setText(" Zoom - ");
        jButtonZoomLess.setFocusable(false);
        jButtonZoomLess.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonZoomLess.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonZoomLess.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonZoomLessActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonZoomLess);

        jButtonFit.setText(" Fit ");
        jButtonFit.setFocusable(false);
        jButtonFit.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonFit.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonFit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonFitActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonFit);

        jButtonDelete.setText(" Delete ");
        jButtonDelete.setFocusable(false);
        jButtonDelete.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonDelete.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDeleteActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonDelete);

        jToolBar2.setFloatable(false);
        jToolBar2.setRollover(true);

        jCheckBoxShowPlanning.setText("Show Planning");
        jCheckBoxShowPlanning.setFocusable(false);
        jCheckBoxShowPlanning.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowPlanning.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowPlanning.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowPlanningActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowPlanning);

        jCheckBoxCrab.setText(" Crab ");
        jCheckBoxCrab.setFocusable(false);
        jCheckBoxCrab.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxCrab.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxCrab.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxCrabActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxCrab);

        jCheckBoxReverse.setText(" Reverse ");
        jCheckBoxReverse.setFocusable(false);
        jCheckBoxReverse.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxReverse.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxReverse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxReverseActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxReverse);

        jCheckBoxShowOutlines.setText(" Show Outlines ");
        jCheckBoxShowOutlines.setFocusable(false);
        jCheckBoxShowOutlines.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowOutlines.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowOutlines.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowOutlinesActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowOutlines);

        jCheckBoxShowPlanOutline.setText(" Show Plan  Exclusion Outline ");
        jCheckBoxShowPlanOutline.setFocusable(false);
        jCheckBoxShowPlanOutline.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowPlanOutline.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowPlanOutline.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowPlanOutlineActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowPlanOutline);

        jCheckBoxShowControlPath.setText(" Show Control Path ");
        jCheckBoxShowControlPath.setFocusable(false);
        jCheckBoxShowControlPath.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowControlPath.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowControlPath.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowControlPathActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowControlPath);

        jCheckBoxLabelControlPoints.setText(" Label Points ");
        jCheckBoxLabelControlPoints.setFocusable(false);
        jCheckBoxLabelControlPoints.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxLabelControlPoints.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxLabelControlPoints.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxLabelControlPointsActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxLabelControlPoints);

        jCheckBoxShowGrid.setText(" Show Grid ");
        jCheckBoxShowGrid.setFocusable(false);
        jCheckBoxShowGrid.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowGrid.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowGrid.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowGridActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowGrid);

        jCheckBoxLabelGrid.setText(" Label Grid ");
        jCheckBoxLabelGrid.setFocusable(false);
        jCheckBoxLabelGrid.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxLabelGrid.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxLabelGrid.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxLabelGridActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxLabelGrid);

        jCheckBoxSimulation.setText(" Simulation ");
        jCheckBoxSimulation.setFocusable(false);
        jCheckBoxSimulation.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxSimulation.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxSimulation.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxSimulationActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxSimulation);

        jCheckBoxShowSideCurves.setText(" Show Side Curves ");
        jCheckBoxShowSideCurves.setFocusable(false);
        jCheckBoxShowSideCurves.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowSideCurves.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowSideCurves.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowSideCurvesActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowSideCurves);

        jCheckBoxShowCenterCurve.setText(" Show Center Curve ");
        jCheckBoxShowCenterCurve.setFocusable(false);
        jCheckBoxShowCenterCurve.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowCenterCurve.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowCenterCurve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowCenterCurveActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowCenterCurve);

        jCheckBoxExclusiveTracks.setText(" Exclusive Tracks");
        jCheckBoxExclusiveTracks.setFocusable(false);
        jCheckBoxExclusiveTracks.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxExclusiveTracks.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxExclusiveTracks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxExclusiveTracksActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxExclusiveTracks);

        jLabelStatus.setText("Status:");

        jMenu1.setText("File");

        jMenuItemFileSaveAs.setText("Save As ....");
        jMenuItemFileSaveAs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemFileSaveAsActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemFileSaveAs);

        jMenuItemFileOpen.setText("Open ...");
        jMenuItemFileOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemFileOpenActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemFileOpen);

        jMenuRecentFiles.setText("Recent Files");
        jMenu1.add(jMenuRecentFiles);

        jMenuImport.setText("Import");

        jMenuItemImportDXFBackground.setText("Import Shapes from DXF as Background ...");
        jMenuItemImportDXFBackground.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemImportDXFBackgroundActionPerformed(evt);
            }
        });
        jMenuImport.add(jMenuItemImportDXFBackground);

        jMenuItemImportDXFBoundaries.setText("Import Lines From DXF as Boundaries ...");
        jMenuItemImportDXFBoundaries.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemImportDXFBoundariesActionPerformed(evt);
            }
        });
        jMenuImport.add(jMenuItemImportDXFBoundaries);

        jMenu1.add(jMenuImport);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");

        jMenuItemClear.setText("Clear");
        jMenuItemClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemClearActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemClear);

        jMenuItemChangeFields.setText("Change AGV Frame/Slow/Stop Fields");
        jMenu2.add(jMenuItemChangeFields);

        jMenuItemSetProperty.setText("Set Property ...");
        jMenuItemSetProperty.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSetPropertyActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemSetProperty);

        jMenuItemDelete.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DELETE, 0));
        jMenuItemDelete.setText("Delete Selection");
        jMenuItemDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemDeleteActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemDelete);

        jMenuBar1.add(jMenu2);

        jMenuMove.setText("Move");
        jMenuMove.setEnabled(false);

        jMenuItemUp.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_UP, 0));
        jMenuItemUp.setText("Up");
        jMenuItemUp.setEnabled(false);
        jMenuItemUp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemUpActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemUp);

        jMenuItemDown.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DOWN, 0));
        jMenuItemDown.setText("Down");
        jMenuItemDown.setEnabled(false);
        jMenuItemDown.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemDownActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemDown);

        jMenuItemLeft.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_LEFT, 0));
        jMenuItemLeft.setText("Left");
        jMenuItemLeft.setEnabled(false);
        jMenuItemLeft.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemLeftActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemLeft);

        jMenuItemRight.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_RIGHT, 0));
        jMenuItemRight.setText("Right");
        jMenuItemRight.setEnabled(false);
        jMenuItemRight.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemRightActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemRight);

        jMenuBar1.add(jMenuMove);

        jMenuConnections.setText("Connections");

        jCheckBoxMenuItemConnectedToVehicle.setText("Connect to Vehicle");
        jCheckBoxMenuItemConnectedToVehicle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemConnectedToVehicleActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemConnectedToVehicle);

        jCheckBoxMenuItemDebugVehicleComm.setSelected(true);
        jCheckBoxMenuItemDebugVehicleComm.setText("Debug Vehicle Comm");
        jCheckBoxMenuItemDebugVehicleComm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemDebugVehicleCommActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemDebugVehicleComm);

        jCheckBoxMenuItemConnectToObsDetect.setText("Connect to Obstacle Detection");
        jCheckBoxMenuItemConnectToObsDetect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemConnectToObsDetectActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemConnectToObsDetect);

        jCheckBoxMenuItemDebugObsDetComm.setSelected(true);
        jCheckBoxMenuItemDebugObsDetComm.setText("Debug Obstacle Detect Comm");
        jCheckBoxMenuItemDebugObsDetComm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemDebugObsDetCommActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemDebugObsDetComm);

        jCheckBoxMenuItemConnectToVehicleManual.setText("Connect To Vehicle (Manual Goal) ");
        jCheckBoxMenuItemConnectToVehicleManual.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemConnectToVehicleManualActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemConnectToVehicleManual);

        jMenuBar1.add(jMenuConnections);

        jMenuChecks.setText("Checks");

        jMenuItemReCheckPath.setText("Re-Check Path");
        jMenuItemReCheckPath.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemReCheckPathActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemReCheckPath);

        jMenuItemForceReplanning.setText("Force replanning");
        jMenuItemForceReplanning.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemForceReplanningActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemForceReplanning);

        jCheckBoxMenuItemReplanOnAllChanges.setText("Replan on all changes");
        jCheckBoxMenuItemReplanOnAllChanges.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemReplanOnAllChangesActionPerformed(evt);
            }
        });
        jMenuChecks.add(jCheckBoxMenuItemReplanOnAllChanges);

        jMenuItemSwapGoalStart.setText("Swap Goal/Start");
        jMenuItemSwapGoalStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSwapGoalStartActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemSwapGoalStart);

        jMenuItemPlotLastCntrlPtsSent.setText("Plot Last Contrl Pts Sent");
        jMenuItemPlotLastCntrlPtsSent.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemPlotLastCntrlPtsSentActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemPlotLastCntrlPtsSent);

        jCheckBoxMenuItemPlotAllCntlrPts.setSelected(true);
        jCheckBoxMenuItemPlotAllCntlrPts.setText("Plot All Contrl Pts Sent");
        jCheckBoxMenuItemPlotAllCntlrPts.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed(evt);
            }
        });
        jMenuChecks.add(jCheckBoxMenuItemPlotAllCntlrPts);

        jMenuBar1.add(jMenuChecks);

        jMenuBackground.setText("Background");

        jCheckBoxMenuItemShowBackground.setSelected(true);
        jCheckBoxMenuItemShowBackground.setText("Show Background");
        jCheckBoxMenuItemShowBackground.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemShowBackgroundActionPerformed(evt);
            }
        });
        jMenuBackground.add(jCheckBoxMenuItemShowBackground);

        jMenuItem1.setText("Clear");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenuBackground.add(jMenuItem1);

        jMenuBar1.add(jMenuBackground);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jToolBar2, javax.swing.GroupLayout.PREFERRED_SIZE, 876, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                            .addComponent(jLabelStatus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jToolBar2, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabelStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 339, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void Clear() {
        Planner.startPP = null;
        this.jCheckBoxSimulation.setSelected(false);
        this.jCheckBoxShowOutlines.setEnabled(true);
        this.splinePanel1.Clear();
    }

    private void jMenuItemClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemClearActionPerformed
        this.Clear();
    }//GEN-LAST:event_jMenuItemClearActionPerformed

    private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
        this.Clear();
    }//GEN-LAST:event_jButtonClearActionPerformed

    private void setMoveEnabled(boolean _enabled) {
        this.jMenuMove.setEnabled(_enabled);
        this.jMenuItemUp.setEnabled(_enabled);
        this.jMenuItemDown.setEnabled(_enabled);
        this.jMenuItemLeft.setEnabled(_enabled);
        this.jMenuItemRight.setEnabled(_enabled);
    }

    private void jRadioButtonStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonStartActionPerformed
        if (this.jRadioButtonStart.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.START);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonStartActionPerformed

    private void jRadioButtonGoalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonGoalActionPerformed
        if (this.jRadioButtonGoal.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.GOAL);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonGoalActionPerformed

    private void jRadioButtonObstacleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonObstacleActionPerformed
        if (this.jRadioButtonObstacle.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.OBSTACLE);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonObstacleActionPerformed

    private void jCheckBoxShowPlanningActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowPlanningActionPerformed
        this.splinePanel1.setShowPlanning(this.jCheckBoxShowPlanning.isSelected());
    }//GEN-LAST:event_jCheckBoxShowPlanningActionPerformed

    private void jCheckBoxShowOutlinesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowOutlinesActionPerformed
        this.splinePanel1.setShowOutline(this.jCheckBoxShowOutlines.isSelected());
    }//GEN-LAST:event_jCheckBoxShowOutlinesActionPerformed

    private void jButtonZoomMoreActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonZoomMoreActionPerformed
        this.changeZoom(1.2);
    }//GEN-LAST:event_jButtonZoomMoreActionPerformed

    private void jButtonZoomLessActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonZoomLessActionPerformed
        this.changeZoom(1.0 / 1.2f);
    }//GEN-LAST:event_jButtonZoomLessActionPerformed

    private void jRadioButtonSelectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonSelectActionPerformed
        if (this.jRadioButtonSelect.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.SELECT);
            this.setMoveEnabled(true);
        }
    }//GEN-LAST:event_jRadioButtonSelectActionPerformed

    private void jCheckBoxLabelControlPointsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxLabelControlPointsActionPerformed
        this.splinePanel1.setLabelControlPoints(this.jCheckBoxLabelControlPoints.isSelected());
    }//GEN-LAST:event_jCheckBoxLabelControlPointsActionPerformed

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        this.centerDrawPanelViewPort();
    }//GEN-LAST:event_formComponentResized

    public void Fit() {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension pref_size = this.splinePanel1.getPreferredSize();
        Rectangle2D.Double rectB = this.splinePanel1.getBoundingRect();
//        System.out.println("rectB = " + rectB);
        if (null == rectB || rectB.width < 1e-3f || rectB.height < 1e-3f) {
            return;
        }
        int whmaxb = (int) Math.max(rectB.height, rectB.width);
//        System.out.println("whmaxb = " + whmaxb);
        int whmax = Math.max(rect.height, rect.width);
//        System.out.println("whmax = " + whmax);
        int whmax2 = Math.max(whmax, whmaxb);
//        System.out.println("whmax2 = " + whmax2);
        double wscale = ((double) rect.width) / ((double) rectB.width);
//        System.out.println("wscale = " + wscale);
        double hscale = ((double) rect.height) / ((double) rectB.height);
//        System.out.println("hscale = " + hscale);
        double scale = Math.min(wscale, hscale);
        this.splinePanel1.setPreferredSize(new Dimension(rect.width, rect.height));
        //this.splinePanel1.setPreferredSize(new Dimension((int) Math.max(rectB.width, rect.width), (int) Math.max(rect.height, rectB.height)));
        this.splinePanel1.setZoomScale((float) scale);
        this.splinePanel1.setTranslateX(-rectB.x * scale);
        this.splinePanel1.setTranslateY(-rectB.y * scale);
        vp.setViewPosition(new Point(0, 0));
    }

    private void jButtonFitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonFitActionPerformed
        Fit();
    }//GEN-LAST:event_jButtonFitActionPerformed

    public static LinkedList parseList(String s) {
        s = s.trim();
        int left_sq_paren_index = s.indexOf('[');
        if (left_sq_paren_index < 0) {
            return null;
        }
        int right_sq_paren_index = s.lastIndexOf(']');
        if (right_sq_paren_index < left_sq_paren_index) {
            return null;
        }
        s = s.substring(left_sq_paren_index + 1, right_sq_paren_index);
        s = s.trim();
        LinkedList ll = new LinkedList();
        int depth = 0;
        int start = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '[') {
                if (depth == 0) {
                    start = i;
                }
                depth++;
            } else if (c == ']') {
                depth--;
                if (depth == 0) {
                    try {
                        String clssname = s.substring(0, start);
                        int c_index = clssname.indexOf(',');
                        if (c_index > 0) {
                            clssname = clssname.substring(0, c_index);
                        }
                        c_index = clssname.indexOf('[');
                        if (c_index > 0) {
                            clssname = clssname.substring(0, c_index).trim();
                        }
                        c_index = clssname.indexOf('{');
                        if (c_index > 0) {
                            clssname = clssname.substring(0, c_index).trim();
                        }
                        Class clss = SplineTestJFrame.class.getClassLoader().loadClass(clssname);
                        Method value_of = clss.getMethod("valueOf", String.class);
                        Object o = value_of.invoke(null, s.substring(0, i + 1));
                        if (o != null) {
                            ll.add(o);
                        }
                    } catch (Exception e) {
                        printException(e);
                    }
                    s = s.substring(i + 1);
                    s = s.trim();
                    if (s.startsWith(",")) {
                        s = s.substring(1);
                        s = s.trim();
                    }
                    i = 0;
                }
            }
        }
        return ll;
    }

    private String splinePanelPropertiesToString() {
        try {
            this.splinePanel1.removeImproperBoundaries();
            Class clss = this.splinePanel1.getClass();
            Method ma[] = clss.getDeclaredMethods();
            List<Method> lm = Arrays.asList(ma);
            Collections.sort(lm, new Comparator<Method>() {
                @Override
                public int compare(Method t, Method t1) {
                    return t.getName().compareTo(t1.getName());
                }
            });
            Point p = this.getLocation();
            Dimension sz = this.getSize();
            ma = lm.toArray(new Method[lm.size()]);
            StringBuffer sb = new StringBuffer();
            sb.append("FramePosX=");
            sb.append(p.x);
            sb.append("\n");
            sb.append("FramePosY=");
            sb.append(p.y);
            sb.append("\n");
            sb.append("FrameSizeWidth=");
            sb.append(sz.width);
            sb.append("\n");
            sb.append("FrameSizeHeight=");
            sb.append(sz.height);
            sb.append("\n");
            for (int i = 0; i < ma.length; i++) {
                Method method = ma[i];
                if (method.getName().startsWith("get")) {
                    Class paramtypes[] = method.getParameterTypes();
                    if (null != paramtypes && paramtypes.length != 0) {
                        continue;
                    }
                    sb.append(method.getName().substring(3));
                    sb.append("=");
                    try {
                        sb.append(method.invoke(this.splinePanel1, (Object[]) null));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    sb.append("\n");
                } else if (method.getName().startsWith("is")) {
                    Class paramtypes[] = method.getParameterTypes();
                    if (null != paramtypes && paramtypes.length != 0) {
                        continue;
                    }
                    sb.append(method.getName().substring(2));
                    sb.append("=");
                    try {
                        sb.append(method.invoke(this.splinePanel1, (Object[]) null));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    sb.append("\n");
                }
            }
            return sb.toString();
        } catch (Exception e) {
            printException(e);
        }
        return null;
    }

    private void setSplinePanelPropsFromReader(BufferedReader br) {
        try {
            this.DisconnectFromObsDetection();
            this.DisconnectFromVehicle();
            this.splinePanel1.incrementDelayReplanCount();
            Class clss = this.splinePanel1.getClass();
            Method ma[] = clss.getDeclaredMethods();
            Map<String, Method> methodMap = new HashMap<>();
            for (Method m : ma) {
                methodMap.put(m.getName(), m);
            }
            String line;
            Point p = this.getLocation();
            Dimension sz = this.getSize();
            boolean FrameSizeSet = false;
            boolean FramePosSet = false;
            while ((line = br.readLine()) != null) {
                int eq_index = line.indexOf('=');
                if (eq_index < 0) {
                    continue;
                }
                String var = line.substring(0, eq_index).trim();
                String val = line.substring(eq_index + 1).trim();
                if(var.equalsIgnoreCase("FramePosX")) {
                    int new_x   = Integer.valueOf(val);
                    if(new_x != p.x) {
                        p.x = new_x;
                        FramePosSet = true;
                    }
                    continue;
                }
                if(var.equalsIgnoreCase("FramePosY")) {
                    int new_y   = Integer.valueOf(val);
                    if(new_y != p.y) {
                        p.y = new_y;
                        FramePosSet = true;
                    }
                    continue;
                }
                if(var.equalsIgnoreCase("FrameSizeWidth")) {
                    int new_width   = Integer.valueOf(val);
                    if(new_width != sz.width) {
                        sz.width = new_width;
                        FrameSizeSet = true;
                    }
                    continue;
                }
                if(var.equalsIgnoreCase("FrameSizeHeight")) {
                    int new_height   = Integer.valueOf(val);
                    if(new_height != sz.height) {
                        sz.height = new_height;
                        FrameSizeSet = true;
                    }
                    continue;
                }
                String setMethodName = "set" + var;
                Method set_method = methodMap.get(setMethodName);
                if (null != set_method) {
                    Class paramtypes[] = set_method.getParameterTypes();
                    if (null == paramtypes) {
                        continue;
                    }
                    if (paramtypes.length != 1) {
                        continue;
                    }
                    Object o = null;
                    Method value_of = null;
                    try {
                        value_of = paramtypes[0].getDeclaredMethod("valueOf", String.class);
                        o = value_of.invoke((Class[]) null, val);
                    } catch (Exception e) {
                    }
                    if (paramtypes[0] == double.class) {
                        o = Double.valueOf(val);
                    } else if (paramtypes[0] == float.class) {
                        o = Float.valueOf(val);
                    } else if (paramtypes[0] == int.class) {
                        o = Integer.valueOf(val);
                    } else if (paramtypes[0] == boolean.class) {
                        o = Boolean.valueOf(val);
                    } else if (paramtypes[0].isAssignableFrom(LinkedList.class)) {
                        LinkedList ll = parseList(val);
                        o = ll;
                    }
                    if (null != o) {
                        set_method.invoke(this.splinePanel1, o);
                    } else {
                        try {
                            if(val.length() < 1 || val.compareTo("null") == 0) {
                                set_method.invoke(this.splinePanel1, new Object[]{ null });
                            } else {
                                set_method.invoke(this.splinePanel1, val);
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                } else {
                    System.err.println("No method in " + clss + " named " + setMethodName);
                }
            }
            this.splinePanel1.removeImproperBoundaries();
            this.jCheckBoxLabelControlPoints.setSelected(this.splinePanel1.isLabelControlPoints());
            this.jCheckBoxShowOutlines.setSelected(this.splinePanel1.isShowOutline());
            this.jCheckBoxLabelGrid.setSelected(this.splinePanel1.isLabelGrid());
            this.jCheckBoxShowPlanning.setSelected(this.splinePanel1.isShowPlanning());
            this.jCheckBoxShowGrid.setSelected(this.splinePanel1.isShowGrid());
            this.jCheckBoxShowCenterCurve.setSelected(this.splinePanel1.isShowCenterCurve());
            this.jCheckBoxShowSideCurves.setSelected(this.splinePanel1.isShowSideCurves());
            this.jCheckBoxCrab.setSelected(this.splinePanel1.isCrab());
            this.jCheckBoxReverse.setSelected(this.splinePanel1.isReverse());
            this.jCheckBoxExclusiveTracks.setSelected(this.splinePanel1.isExclusivePaths());
            this.jCheckBoxShowPlanOutline.setSelected(this.splinePanel1.isShowPlanOutline());
            this.splinePanel1.setCarriers(null);
            this.splinePanel1.StopSimulation();
            this.jCheckBoxSimulation.setSelected(false);
            this.splinePanel1.setCarriers(null);
            this.jCheckBoxMenuItemPlotAllCntlrPts.setSelected(this.splinePanel1.isPlotAllCtrlPtsSent());
            this.jCheckBoxShowControlPath.setSelected(this.splinePanel1.isShowControlPath());
            switch (this.splinePanel1.getDrawMode()) {
                case SELECT:
                    this.jRadioButtonSelect.setSelected(true);
                    break;

                case START:
                    this.jRadioButtonStart.setSelected(true);
                    break;

                case GOAL:
                    this.jRadioButtonGoal.setSelected(true);
                    break;

                case OBSTACLE:
                    this.jRadioButtonObstacle.setSelected(true);
                    break;

                case BOUNDARY:
                    this.jRadioButtonBoundary.setSelected(true);

                case VERT_BOUNDARY:
                    this.jRadioButtonVertBoundary.setSelected(true);
                    break;

                case HORZ_BOUNDARY:
                    this.jRadioButtonHorzBoundary.setSelected(true);
                    break;

                case PAN:
                    this.jRadioButtonPan.setSelected(true);
                    break;
            }
            this.debugVehicleComm = this.splinePanel1.isDebugVehicleComm();
            this.jCheckBoxMenuItemDebugVehicleComm.setSelected(debugVehicleComm);
            this.debugObsDetComm = this.splinePanel1.isDebugObsDetComm();
            this.jCheckBoxMenuItemDebugObsDetComm.setSelected(debugObsDetComm);
            this.jCheckBoxMenuItemShowBackground.setSelected(this.splinePanel1.isShowBackgroundShapes());
            if (this.splinePanel1.isConnectedToVehicle()) {
                this.splinePanel1.setReplanOnAllChanges(false);
            } else {
                this.jCheckBoxMenuItemReplanOnAllChanges.setSelected(this.splinePanel1.isReplanOnAllChanges());
            }
            this.splinePanel1.setManualGoal(false);
            this.DisconnectFromObsDetection();
            this.DisconnectFromVehicle();
            this.jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
            this.jCheckBoxMenuItemConnectToVehicleManual.setSelected(false);
            this.jCheckBoxMenuItemConnectToObsDetect.setSelected(false);
            this.jCheckBoxMenuItemConnectedToVehicle.setEnabled(true);
            this.jCheckBoxMenuItemConnectToVehicleManual.setEnabled(true);
            this.jCheckBoxMenuItemConnectToObsDetect.setEnabled(true);
            if(FrameSizeSet) {
                this.setSize(sz);
            }
            if(FramePosSet) {
                this.setLocation(p);
            }
            java.awt.EventQueue.invokeLater(new Runnable() {
                @Override
                public void run() {
                    Fit();
                }
            });
        } catch (Exception e) {
            printException(e);
        } finally {
            this.splinePanel1.decrementDelayReplanCount();
            this.splinePanel1.replan();
            this.splinePanel1.repaint();
        }
    }

    private void jMenuItemSetPropertyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSetPropertyActionPerformed
        try {
            String new_props = PropertiesJPanel.showDialog(this,
                    splinePanelPropertiesToString());
            if (null == new_props) {
                return;
            }
            BufferedReader br = new BufferedReader(new StringReader(new_props));
            this.setSplinePanelPropsFromReader(br);
        } catch (Exception e) {
            printException(e);
        }
    }//GEN-LAST:event_jMenuItemSetPropertyActionPerformed

    private static void printException(Exception e) {
        System.out.println("");
        System.out.flush();
        System.err.println("");
        System.err.flush();
        if (null != e.getCause()) {
            e.getCause().printStackTrace();
        }
        System.err.println("");
        System.err.flush();
        e.printStackTrace();
        System.err.println("");
        System.err.flush();
    }
    private void jRadioButtonBoundaryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonBoundaryActionPerformed
        if (this.jRadioButtonBoundary.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.BOUNDARY);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonBoundaryActionPerformed
    private Collection<File> RecentFiles;

    /**
     * Get the value of RecentFiles
     *
     * @return the value of RecentFiles
     */
    public Collection<File> getRecentFiles() {
        return RecentFiles;
    }

    public void loadRecentFiles() {
        Collection<File> newRecentFiles = new LinkedHashSet<>();
        try (BufferedReader br = new BufferedReader(new FileReader(recentFileListFile))) {
            String line;
            while (null != (line = br.readLine())) {
                line = line.trim();
                if (line.length() < 1) {
                    continue;
                }
                newRecentFiles.add(new File(line));
            }
            this.setRecentFiles(newRecentFiles);
        } catch (Exception e) {
            printException(e);
        }
    }
    static private final File recentFileListFile =
            new File(System.getProperty("user.home"), ".spline_test_recent_files.txt");

    /**
     * Set the value of RecentFiles
     *
     * @param RecentFiles new value of RecentFiles
     */
    public void setRecentFiles(Collection<File> RecentFiles) {
        this.RecentFiles = RecentFiles;
        this.jMenuRecentFiles.removeAll();
        try (PrintStream ps = new PrintStream(new FileOutputStream(recentFileListFile))) {
            if (null != this.RecentFiles) {
                for (final File f : this.RecentFiles) {
                    JMenuItem mi = new JMenuItem(f.getName());
                    mi.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent ae) {
                            try {
                                BufferedReader br = new BufferedReader(new FileReader(f));
                                setSplinePanelPropsFromReader(br);
                                Fit();
                            } catch (Exception exception) {
                                printException(exception);
                            }
                        }
                    });
                    this.jMenuRecentFiles.add(mi);
                    ps.println(f.getCanonicalPath());
                }
            }
            ps.close();
        } catch (Exception exception) {
            printException(exception);
        }
    }

    private void addRecentFile(File f) {
        Collection<File> newRecentFiles = new LinkedHashSet<>();
        if (null != this.RecentFiles) {
            newRecentFiles.addAll(this.RecentFiles);
        }
        newRecentFiles.add(f);
        this.setRecentFiles(newRecentFiles);
    }

    public void BrowseOpenFile() {
        BufferedReader br = null;
        try {
            JFileChooser chooser = new JFileChooser();
            int chooser_ret = chooser.showOpenDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                br = new BufferedReader(new FileReader(f));
                this.setSplinePanelPropsFromReader(br);
                this.addRecentFile(f);
                Fit();
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
                if (null != br) {
                    br.close();
                }
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    public void BrowseImportDXFBoundaries() {
        try {
            JFileChooser chooser = new JFileChooser();
            chooser.setFileFilter(new FileNameExtensionFilter("Drawing Exchange Format", "dxf"));
            int chooser_ret = chooser.showOpenDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                List<Boundary> boundaries = this.splinePanel1.getBoundaries();
                if (boundaries == null) {
                    boundaries = new LinkedList<>();
                }
                FileInputStream fis = new FileInputStream(f);
                DXFLineShapeExtractor extractor = new DXFLineShapeExtractor(fis);
                String scale_string = JOptionPane.showInputDialog("Scale ?", extractor.getScale());
                try {
                    extractor.setScale(Double.valueOf(scale_string));
                } catch (Exception e) {
                    e.printStackTrace();
                }
                List<Line2Dd> lines = extractor.readLinesFromAllLayers();
                for (Line2Dd l2d : lines) {
                    boundaries.add(new Boundary(l2d.x1, l2d.y1, l2d.x2, l2d.y2));
                }
                try {
                    extractor.close();
                } catch (Exception e) {
                }
                try {
                    fis.close();
                } catch (Exception e) {
                }
                this.splinePanel1.setBoundaries(boundaries);
                Fit();
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    public void BrowseImportDXFBackground() {
        try {
            JFileChooser chooser = new JFileChooser();
            chooser.setFileFilter(new FileNameExtensionFilter("Drawing Exchange Format", "dxf"));
            int chooser_ret = chooser.showOpenDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                List<ShapeWTransform> backgroundShapes = this.splinePanel1.getBackgroundShapes();
                if (backgroundShapes == null) {
                    backgroundShapes = new LinkedList<>();
                }
                FileInputStream fis = new FileInputStream(f);
                DXFLineShapeExtractor extractor = new DXFLineShapeExtractor(fis);
                String scale_string = JOptionPane.showInputDialog("Scale ?", extractor.getScale());
                try {
                    extractor.setScale(Double.valueOf(scale_string));
                } catch (Exception e) {
                    e.printStackTrace();
                }
                List<ShapeWTransform> newShapes = extractor.readShapeWTransformFromAllLayers();
                backgroundShapes.addAll(newShapes);
                try {
                    extractor.close();
                } catch (Exception e) {
                }
                try {
                    fis.close();
                } catch (Exception e) {
                }
                this.splinePanel1.setBackgroundShapes(backgroundShapes);
                Fit();
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    public void BrowseSaveFile() {
        PrintStream ps = null;
        try {
            JFileChooser chooser = new JFileChooser();
            int chooser_ret = chooser.showSaveDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                String s = this.splinePanelPropertiesToString();
                ps = new PrintStream(new FileOutputStream(f));
                ps.println(s);
                ps.close();
                ps = null;
                this.addRecentFile(f);
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
                if (null != ps) {
                    ps.close();
                }
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    private void jMenuItemFileSaveAsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemFileSaveAsActionPerformed
        this.BrowseSaveFile();
    }//GEN-LAST:event_jMenuItemFileSaveAsActionPerformed

    private void jMenuItemFileOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemFileOpenActionPerformed
        this.BrowseOpenFile();
    }//GEN-LAST:event_jMenuItemFileOpenActionPerformed

    private void jMenuItemDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemDeleteActionPerformed
        this.splinePanel1.DeleteSelection();
    }//GEN-LAST:event_jMenuItemDeleteActionPerformed

    private void jButtonDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDeleteActionPerformed
        this.splinePanel1.DeleteSelection();
    }//GEN-LAST:event_jButtonDeleteActionPerformed
    private final static Point2Dd upMove = new Point2Dd(0f, +1f);

    private void jMenuItemUpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemUpActionPerformed
        try {
            this.splinePanel1.moveSelection(upMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemUpActionPerformed
    private final static Point2Dd downMove = new Point2Dd(0f, -1f);

    private void jMenuItemDownActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemDownActionPerformed
        try {
            this.splinePanel1.moveSelection(downMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemDownActionPerformed
    private final static Point2Dd leftMove = new Point2Dd(-1f, 0f);

    private void jMenuItemLeftActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemLeftActionPerformed
        try {
            this.splinePanel1.moveSelection(leftMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemLeftActionPerformed
    private final static Point2Dd rightMove = new Point2Dd(+1f, 0f);

    private void jMenuItemRightActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemRightActionPerformed
        try {
            this.splinePanel1.moveSelection(rightMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemRightActionPerformed

    private void jRadioButtonHorzBoundaryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonHorzBoundaryActionPerformed
        if (this.jRadioButtonHorzBoundary.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.HORZ_BOUNDARY);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonHorzBoundaryActionPerformed

    private void jRadioButtonVertBoundaryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonVertBoundaryActionPerformed
        if (this.jRadioButtonVertBoundary.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.VERT_BOUNDARY);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonVertBoundaryActionPerformed

    private void jCheckBoxShowGridActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowGridActionPerformed
        this.splinePanel1.setShowGrid(this.jCheckBoxShowGrid.isSelected());
    }//GEN-LAST:event_jCheckBoxShowGridActionPerformed

    private void jCheckBoxLabelGridActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxLabelGridActionPerformed
        this.splinePanel1.setLabelGrid(this.jCheckBoxLabelGrid.isSelected());
    }//GEN-LAST:event_jCheckBoxLabelGridActionPerformed

    private void jRadioButtonPanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonPanActionPerformed
        if (this.jRadioButtonPan.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.PAN);
        }
    }//GEN-LAST:event_jRadioButtonPanActionPerformed

    private void formWindowStateChanged(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowStateChanged
        Fit();
    }//GEN-LAST:event_formWindowStateChanged

    private void jCheckBoxSimulationActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxSimulationActionPerformed
        try {
            if (this.jCheckBoxSimulation.isSelected()) {
//            this.jCheckBoxShowOutlines.setSelected(false);
//            this.jCheckBoxShowOutlines.setEnabled(false);
                this.splinePanel1.StartSimulation();
            } else {
                this.splinePanel1.StopSimulation();
//            this.jCheckBoxShowOutlines.setEnabled(true);
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }//GEN-LAST:event_jCheckBoxSimulationActionPerformed

    private void jCheckBoxShowCenterCurveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowCenterCurveActionPerformed
        this.splinePanel1.setShowCenterCurve(this.jCheckBoxShowCenterCurve.isSelected());
    }//GEN-LAST:event_jCheckBoxShowCenterCurveActionPerformed

    private void jCheckBoxShowSideCurvesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowSideCurvesActionPerformed
        this.splinePanel1.setShowSideCurves(this.jCheckBoxShowSideCurves.isSelected());
    }//GEN-LAST:event_jCheckBoxShowSideCurvesActionPerformed

    private void jMenuItemImportDXFBoundariesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemImportDXFBoundariesActionPerformed
        this.BrowseImportDXFBoundaries();
    }//GEN-LAST:event_jMenuItemImportDXFBoundariesActionPerformed

    private void jMenuItemImportDXFBackgroundActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemImportDXFBackgroundActionPerformed
        this.BrowseImportDXFBackground();
    }//GEN-LAST:event_jMenuItemImportDXFBackgroundActionPerformed

    private void jCheckBoxMenuItemConnectedToVehicleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemConnectedToVehicleActionPerformed
        this.splinePanel1.setManualGoal(false);
        if (this.jCheckBoxMenuItemConnectedToVehicle.isSelected()) {
            ConnectToVehicle();
            this.jCheckBoxMenuItemConnectToVehicleManual.setSelected(false);
            this.jCheckBoxMenuItemConnectToVehicleManual.setEnabled(false);
        } else {
            DisconnectFromVehicle();
            this.jCheckBoxMenuItemConnectToVehicleManual.setEnabled(true);
        }
    }//GEN-LAST:event_jCheckBoxMenuItemConnectedToVehicleActionPerformed

    private void jCheckBoxCrabActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxCrabActionPerformed
        this.splinePanel1.setCrab(this.jCheckBoxCrab.isSelected());
    }//GEN-LAST:event_jCheckBoxCrabActionPerformed

    private void jCheckBoxMenuItemConnectToObsDetectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemConnectToObsDetectActionPerformed
        if (this.jCheckBoxMenuItemConnectToObsDetect.isSelected()) {
            this.ConnectToObsDetection();
        } else {
            this.DisconnectFromObsDetection();
        }
    }//GEN-LAST:event_jCheckBoxMenuItemConnectToObsDetectActionPerformed

    private void jCheckBoxExclusiveTracksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxExclusiveTracksActionPerformed
        this.splinePanel1.setExclusivePaths(this.jCheckBoxExclusiveTracks.isSelected());
    }//GEN-LAST:event_jCheckBoxExclusiveTracksActionPerformed

    private void jMenuItemReCheckPathActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemReCheckPathActionPerformed
        try {
            PlannerInput pi = this.splinePanel1.getPlannerInput();
            List<PlannedPath> plannedPaths = this.splinePanel1.getPlannedPaths();
            for (PlannedPath pp : plannedPaths) {
                PlannerPoint last_ppt = null;
                for (PlannerPoint ppt : pp.getControlPoints()) {
                    if (last_ppt != null) {
                        System.out.println("Checking from " + last_ppt);
                        System.out.println("to            " + ppt + " ...");
                        boolean ck = Planner.checkPoint(last_ppt, ppt,
                                pi,
                                true);
                        System.out.println("Planner.checkPoint returned  " + ck);
                        System.out.println("");
                    }
                    last_ppt = ppt;
                }
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }//GEN-LAST:event_jMenuItemReCheckPathActionPerformed

    private void jCheckBoxShowPlanOutlineActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowPlanOutlineActionPerformed
        this.splinePanel1.setShowPlanOutline(this.jCheckBoxShowPlanOutline.isSelected());
    }//GEN-LAST:event_jCheckBoxShowPlanOutlineActionPerformed

    private void jCheckBoxMenuItemDebugVehicleCommActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemDebugVehicleCommActionPerformed
        this.debugVehicleComm = this.jCheckBoxMenuItemDebugVehicleComm.isSelected();
        this.splinePanel1.setDebugVehicleComm(debugVehicleComm);
    }//GEN-LAST:event_jCheckBoxMenuItemDebugVehicleCommActionPerformed
    private boolean debugObsDetComm = false;

    private void jCheckBoxMenuItemDebugObsDetCommActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemDebugObsDetCommActionPerformed
        this.debugObsDetComm = this.jCheckBoxMenuItemDebugObsDetComm.isSelected();
        this.splinePanel1.setDebugObsDetComm(debugObsDetComm);
    }//GEN-LAST:event_jCheckBoxMenuItemDebugObsDetCommActionPerformed

    private void jMenuItemForceReplanningActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemForceReplanningActionPerformed
        this.splinePanel1.forceReplan();
    }//GEN-LAST:event_jMenuItemForceReplanningActionPerformed

    private void jCheckBoxMenuItemShowBackgroundActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemShowBackgroundActionPerformed
        this.splinePanel1.setShowBackgroundShapes(this.jCheckBoxMenuItemShowBackground.isSelected());
        this.splinePanel1.repaint();
    }//GEN-LAST:event_jCheckBoxMenuItemShowBackgroundActionPerformed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        this.splinePanel1.setBackgroundShapes(null);
        this.splinePanel1.repaint();
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jCheckBoxMenuItemReplanOnAllChangesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemReplanOnAllChangesActionPerformed
        this.splinePanel1.setReplanOnAllChanges(this.jCheckBoxMenuItemReplanOnAllChanges.isSelected());
    }//GEN-LAST:event_jCheckBoxMenuItemReplanOnAllChangesActionPerformed

    private void jCheckBoxReverseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxReverseActionPerformed
        this.splinePanel1.setReverse(this.jCheckBoxReverse.isSelected());
    }//GEN-LAST:event_jCheckBoxReverseActionPerformed

    private void jMenuItemSwapGoalStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSwapGoalStartActionPerformed
        this.splinePanel1.swapGoalStart();
    }//GEN-LAST:event_jMenuItemSwapGoalStartActionPerformed

    private void jCheckBoxMenuItemConnectToVehicleManualActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemConnectToVehicleManualActionPerformed
        if (this.jCheckBoxMenuItemConnectToVehicleManual.isSelected()) {
            this.splinePanel1.setManualGoal(true);
            this.splinePanel1.setStartPoints(null);
            this.splinePanel1.setGoalPoints(null);
            ConnectToVehicle();
            this.jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
            this.jCheckBoxMenuItemConnectedToVehicle.setEnabled(false);
        } else {
            DisconnectFromVehicle();
            this.jCheckBoxMenuItemConnectedToVehicle.setEnabled(true);
        }
    }//GEN-LAST:event_jCheckBoxMenuItemConnectToVehicleManualActionPerformed

    public void plotLastCntrlPtsSent() {
        try {
            if (this.last_cntrl_pts_sent_ba == null) {
                System.err.println("jMenuItemPlotLastCntrlPtsSentActionPerformed: this.last_cntrl_pts_sent_ba == null");
                return;
            }
            ByteBuffer bb = ByteBuffer.wrap(this.last_cntrl_pts_sent_ba);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            File f = File.createTempFile("cntrl_pts_" + this.sendControlPointsCount + "_" + this.lastsegid, ".csv");
            PrintStream ps = new PrintStream(new FileOutputStream(f));
            ps.println("x,y");
            for (int i = 12; i < this.last_cntrl_pts_sent_ba.length - 7; i += 8) {
                int ix = bb.getInt(i);
                int iy = bb.getInt(i + 4);
                String s = "" + ix + "," + iy;
                ps.println(s);
                System.out.println(s);
            }
            ps.close();
            String args[] = {"--plotVsLineNumber=true", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                f.getCanonicalPath()};
            diagapplet.plotter.plotterJFrame.main(args);
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }
    private void jMenuItemPlotLastCntrlPtsSentActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemPlotLastCntrlPtsSentActionPerformed
        this.plotLastCntrlPtsSent();
    }//GEN-LAST:event_jMenuItemPlotLastCntrlPtsSentActionPerformed

    private void jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed
        this.splinePanel1.setPlotAllCtrlPtsSent(this.jCheckBoxMenuItemPlotAllCntlrPts.isSelected());
    }//GEN-LAST:event_jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed

    private void jCheckBoxShowControlPathActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowControlPathActionPerformed
        this.splinePanel1.setShowControlPath(this.jCheckBoxShowControlPath.isSelected());
    }//GEN-LAST:event_jCheckBoxShowControlPathActionPerformed
    Thread monitorVehicleThread = null;
    Socket socket_to_vehicle = null;
    private byte obsDetectBa[] = null;
    private Thread obsDetectThread = null;
    private DatagramPacket obsDetectPacket = null;
    private DatagramSocket obsDetectSocket = null;
    private final SocketAddress obsAddress = new InetSocketAddress(5555);
    List<List<Obstacle>> obsHistory = null;
    Map<List<Obstacle>, Double> obsTimeStamps = null;

    public void ReadFromObsDetect() {
        try {
            debugObsDetComm = this.splinePanel1.isDebugObsDetComm();
            obsHistory = new LinkedList<>();
            obsTimeStamps = new HashMap<>();
            int readobsdet_count = 0;
            while (!Thread.currentThread().isInterrupted()) {
                readobsdet_count++;
                if (debugObsDetComm) {
                    System.out.println("readobsdet_count = " + readobsdet_count);
                }
                if (null == obsDetectSocket || null == obsDetectPacket) {
                    return;
                }
                obsDetectSocket.receive(obsDetectPacket);
                ByteBuffer bb = ByteBuffer.wrap(obsDetectPacket.getData());
                if (debugObsDetComm) {
                    System.out.println("ReadFromObsDetectRead:");
                    printByteArray(bb.array());
                }
                double timeStamp = bb.getDouble();
                if (debugObsDetComm) {
                    System.out.println("timeStamp = " + timeStamp);
                }
                int num_obs = bb.getInt();
                if (debugObsDetComm) {
                    System.out.println("num_obs = " + num_obs);
                }
                final List<Obstacle> newObsList = new LinkedList<>();
                List<Obstacle> prevObstacles = null;
                while (obsHistory.size() > 0) {
                    prevObstacles = obsHistory.get(0);
                    try {
                        Double prev_timestamp = obsTimeStamps.get(prevObstacles);
                        if (prev_timestamp != null && timeStamp - prev_timestamp < 5.0) {
                            break;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                        break;
                    }
                    obsHistory.remove(0);
                    obsTimeStamps.remove(prevObstacles);
                }
                for (int i = 0; i < num_obs; i++) {
                    float x = bb.getFloat();
                    float y = bb.getFloat();
                    float vx = bb.getFloat();
                    float vy = bb.getFloat();
                    float radius = bb.getFloat();
                    Obstacle new_obs =
                            new Obstacle(x * 100.0, y * 100.0, radius * 100.0);
                    newObsList.add(new_obs);
                }

                final List<Obstacle> obsListCopy = new LinkedList<>();
                obsListCopy.addAll(newObsList);
                obsHistory.add(obsListCopy);
                java.awt.EventQueue.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        splinePanel1.setTempObstacles(obsListCopy);
                    }
                });
                obsTimeStamps.put(obsListCopy, timeStamp);
                if (null != prevObstacles) {
                    for (int i = 0; i < newObsList.size(); i++) {
                        Obstacle obsi = newObsList.get(i);
                        boolean match_found = false;
                        for (int j = 0; j < prevObstacles.size(); j++) {
                            Obstacle obsj = prevObstacles.get(j);
                            if (obsj.distance(obsi) < 20.0
                                    && Math.abs(obsj.radius - obsi.radius) < 20.0) {
                                match_found = true;
                                break;
                            }
                        }
                        if (!match_found) {
                            newObsList.remove(i);
                            i--;
                        }
                    }
                    java.awt.EventQueue.invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            splinePanel1.setObstacles(newObsList);
                            splinePanel1.replan();
                        }
                    });
                }
                this.obsDetectSocket.close();
                this.obsDetectSocket = new DatagramSocket(5555);
                this.obsDetectSocket.setReuseAddress(true);
                Thread.sleep(100);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void ConnectToObsDetection() {
        try {
            this.DisconnectFromObsDetectionInner();
            obsDetectSocket = new DatagramSocket(5555);
            if (this.debugObsDetComm) {
                System.out.println("Starting obsDetect thread to listen for UDP packets on port :" + obsDetectSocket.getLocalPort());
            }
            this.obsDetectSocket.setReuseAddress(true);
            obsDetectBa = new byte[1024];
            obsDetectPacket = new DatagramPacket(obsDetectBa, obsDetectBa.length);
            obsDetectThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    ReadFromObsDetect();
                }
            }, "obsDetectThread");
            obsDetectThread.start();
            if (!this.jCheckBoxMenuItemConnectToObsDetect.isSelected()) {
                this.jCheckBoxMenuItemConnectToObsDetect.setSelected(true);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void DisconnectFromObsDetectionInner() {
        try {

            if (null != this.obsDetectThread) {
                this.obsDetectThread.interrupt();
                if (null != this.obsDetectSocket) {
                    this.obsDetectSocket.close();
                    this.obsDetectSocket = null;
                }
                this.obsDetectThread.join();
                this.obsDetectThread = null;
            }
            if (null != this.obsDetectSocket) {
                this.obsDetectSocket.close();
                this.obsDetectSocket = null;
            }
            this.obsDetectPacket = null;
            this.obsDetectBa = null;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void DisconnectFromObsDetection() {
        this.DisconnectFromObsDetectionInner();
        if (this.jCheckBoxMenuItemConnectToObsDetect.isSelected()) {
            this.jCheckBoxMenuItemConnectToObsDetect.setSelected(false);
        }
    }

    public static void printByteArray(byte ba[]) {
        //System.out.println("("+ba.length +" bytes)");
        for (int i = 0; i < ba.length; i++) {
            byte b = ba[i];
            System.out.printf("%02X", b);
            if ((i + 1) % 4 == 0) {
                System.out.print(" ");
            }
        }
    }
    private int sendControlPointsCount = 0;

    public void ShowMessageBox(final String s) {
        String ss = s;
        if (ss.length() > 70) {
            ss = ss.substring(0, 69);
        }
        JOptionPane.showMessageDialog(this, ss);
    }

    public void ShowError(final String s) {
        System.out.println("");
        System.out.flush();
        System.err.println(s);
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                ShowMessageBox(s);
            }
        });
    }
    byte last_cntrl_pts_sent_ba[] = null;
    Point2Dd lastGoal;

    public boolean sendControlPoints(Socket socket,
            List<? extends Point2Dd> cntrlPts,
            boolean crab,
            int segsx, int segsy, short segsangle,
            int segex, int segey, short segeangle,
            short segi,
            short speed_mm_s) {
        ByteBuffer bb = null;
        try {
            OutputStream os = socket.getOutputStream();
            sendControlPointsCount++;
            if (debugVehicleComm) {
                System.out.println("sendControlPointsCount = " + sendControlPointsCount);
            }
            if (null == cntrlPts) {
                System.out.println("sendControlPoints : cntrlPts == null");
                return false;
            }
            int num_pts = cntrlPts.size();
            if (num_pts < 2) {
                ShowError("sendControlPoints : num_pts too few: " + num_pts);
                return false;
            }
            if (num_pts > 15) {
                ShowError("sendControlPoints : num_pts too many: " + num_pts);
                return false;
            }
            if (cntrlPts.get(0).distance(cntrlPts.get(num_pts - 1)) < 10) {
                return false;
            }
            int bbsz = 44 + num_pts * 8;
            double start_seg = this.splinePanel1.getSegStartLength() * 10.0;

            //start_seg = 10.0;
            int nsz = cntrlPts.size();
            double end_seg = start_seg;

            //end_seg = 10.0;
            bb = ByteBuffer.allocate(bbsz);
//            System.out.println("bb = " + bb);
//            System.out.println("bb.capacity() = " + bb.capacity());
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort((short) 0x64);
            bb.putShort((short) bbsz);
            if (this.splinePanel1.isCrab()) {
                bb.putShort((short) 2); // send crab spline
            } else {
                bb.putShort((short) 1); // send normal spline
            }
            bb.putShort((short) speed_mm_s); // 200 mm/s

            bb.putShort(segsangle);
            bb.putShort(segeangle);
//                        bb.putShort((short) 0);
//                        bb.putShort((short) 0);
            double startAngle = Math.toRadians(segsangle / 100.0);
            if (speed_mm_s < 0) {
                startAngle += Math.PI;
            }
            double ss = Math.sin(startAngle);
            double cs = Math.cos(startAngle);
            Point2Dd diffu = cntrlPts.get(cntrlPts.size() - 1).diff(cntrlPts.get(0)).unit();
            if (crab) {
                ss = diffu.y;
                cs = diffu.x;
            }
            if (false && this.splinePanel1.isManualGoal()
                    && null != this.last_three_pts_sent
                    && Math.abs(segsx - this.last_three_pts_sent[2]) < 20
                    && Math.abs(segsy - this.last_three_pts_sent[3]) < 20) {
                for (int i = 0; i < 6; i++) {
                    bb.putInt(this.last_three_pts_sent[i]);
                }
            } else {
                bb.putInt(segsx - (int) (cs * start_seg));
                bb.putInt(segsy - (int) (ss * start_seg));
                bb.putInt(segsx);
                bb.putInt(segsy);
                bb.putInt(segsx + (int) (cs * start_seg));
                bb.putInt(segsy + (int) (ss * start_seg));
            }
            for (int i = 1; i < num_pts - 1; i++) {
                Point2Dd pt = cntrlPts.get(i);
                int xi = (int) (pt.x * 10.0);
                int yi = (int) (pt.y * 10.0);
                bb.putInt(xi);
                bb.putInt(yi);
            }
            double endAngle = Math.toRadians(segeangle / 100.0);
            if (speed_mm_s < 0) {
                endAngle += Math.PI;
            }
            double se = Math.sin(endAngle);
            double ce = Math.cos(endAngle);
            if (crab) {

                se = diffu.y;
                ce = diffu.x;
            }
            this.last_three_pts_sent[0] = segex - (int) (ce * end_seg);
            bb.putInt(this.last_three_pts_sent[0]);
            this.last_three_pts_sent[1] = segey - (int) (se * end_seg);
            bb.putInt(this.last_three_pts_sent[1]);
//            System.out.println("bb = " + bb);
            this.last_three_pts_sent[2] = segex;
            bb.putInt(this.last_three_pts_sent[2]);
            this.last_three_pts_sent[3] = segey;
            bb.putInt(this.last_three_pts_sent[3]);
            this.last_three_pts_sent[4] = segex + (int) (ce * end_seg);
            bb.putInt(this.last_three_pts_sent[4]);
            this.last_three_pts_sent[5] = segey + (int) (se * end_seg);
            bb.putInt(this.last_three_pts_sent[5]);

            byte ba[] = bb.array();
            os.write(ba);
            this.last_cntrl_pts_sent_ba = ba;
            if (debugVehicleComm) {
                System.out.println("sendControlPoints Sent:");
                printByteArray(ba);
                System.out.println("");
            }
            if (this.splinePanel1.isPlotAllCtrlPtsSent()) {
                this.plotLastCntrlPtsSent();
            }
            byte h4[] = new byte[4];
            InputStream is = socket.getInputStream();
            bb = ByteBuffer.wrap(h4);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            is.read(h4);
            short type = bb.getShort();
            if (debugVehicleComm) {
                System.out.printf("sendControlPoints response type = 0x%X\n", type);
            }
            short sz = bb.getShort();
            if (debugVehicleComm) {
                System.out.println("sendControlPoints response sz = " + sz);
            }
            if (sz < 4) {
                throw new RuntimeException("Bad size value of " + sz);
            }
            ba = new byte[sz - 4];
            is.read(ba);
            if (debugVehicleComm) {
                System.out.println("sendControlPoints response:");
                printByteArray(ba);
                System.out.println("");
            }

            bb = ByteBuffer.wrap(ba);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            switch (type) {
                case 0x61:
                    short returnvalue = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("returnvalue = " + returnvalue);
                    }
                    short state = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("state = " + state);
                    }
                    setStatusLabel(returnvalue, state, segi);
                    if (returnvalue == 1) {
                        return true;
                    }
                    if (returnvalue == 0) {
                        return true;
                    }
                    System.out.println("sendControlPoints response: return value = " + returnvalue + ", state=" + state);
                    break;
            }
            return false;
        } catch (Exception e) {
            System.err.println("bb=" + bb);
            e.printStackTrace();
        }
        return false;
    }

    public void MonitorVehicle() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                if (CheckVehicle()) {
                    return;
                }
                Thread.sleep(500);
                if (monitorVehicleThread.isInterrupted()) {
                    return;
                }
            }
        } catch (InterruptedException interruptedException) {
//            interruptedException.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void saveSplinePoints(List<? extends Point2Dd> l) {
        try {
            File spline_dir_f = new File(System.getProperty("user.home"), "saved_splines");
            spline_dir_f.mkdirs();
            DateFormat df = DateFormat.getDateTimeInstance();
            String now = df.format(new Date()).trim().replace(' ', '_').replace(',', '_').replace(':', '_').replace('/', ' ').replace('\\', '_').replace('.', '_');
            File spline_save_file = new File(spline_dir_f, "saved_spline_" + now + ".csv");
            PrintStream ps = new PrintStream(new FileOutputStream(spline_save_file, true));
            ps.println("x,y");
            for (Point2Dd pt : l) {
                ps.println(pt.x + "," + pt.y);
            }
            ps.close();
            System.out.println("Saved : " + spline_save_file.getCanonicalPath());
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    public void saveControlPoints(List<? extends Point2Dd> l) {
        try {
            if (null == l || l.size() < 1) {
                return;
            }
            File spline_dir_f = new File(System.getProperty("user.home"), "saved_control_pts");
            spline_dir_f.mkdirs();
            DateFormat df = DateFormat.getDateTimeInstance();
            String now = df.format(new Date()).trim().replace(' ', '_').replace(',', '_').replace(':', '_').replace('/', ' ').replace('\\', '_').replace('.', '_');
            File spline_save_file = new File(spline_dir_f, "saved_control_pts_" + now + ".csv");
            PrintStream ps = new PrintStream(new FileOutputStream(spline_save_file, true));
            ps.println("x,y");
            for (Point2Dd pt : l) {
                ps.println(pt.x + "," + pt.y);
            }
            ps.close();
            System.out.println("Saved : " + spline_save_file.getCanonicalPath());
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }
    public boolean debugVehicleComm = false;
    int last_three_pts_sent[] = new int[6];
    short last_sent_seg_id = -1;
    int lastreturnvalue = -1;
    int laststate = -1;
    int lastsegid = -1;

    public void setStatusLabel(int returnvalue, int state, int segid) {
        if (returnvalue == lastreturnvalue && state == laststate && segid == lastsegid) {
            return;
        }
        String s = "Status : ";
        switch (returnvalue) {
            case 0:
                break;
            case 1:
                s += " Spline command accepted ";
                break;

            case 2:
                s += " Wrong State ";
                break;

            case 3:
                s += " spline error ";
                break;

            default:
                s += " unrecognized return value = " + returnvalue;
                break;
        }
        switch (state) {
            case 0:
                s += " state=Idle ";
                break;

            case 1:
                s += " state=\"Waiting for external command.\" ";
                break;

            case 2:
                s += " state=\"External command received.\" ";
                break;

            default:
                s += " unrecognized state value = " + state;
                break;
        }
        s += " segid=" + segid;
        s += " count=" + this.sendControlPointsCount;
        this.jLabelStatus.setText(s);
        this.lastreturnvalue = returnvalue;
        this.laststate = state;
        this.lastsegid = segid;
    }
    int lastGoalId = -1;

    public boolean CheckVehicle() throws InterruptedException {
        ByteBuffer bb = null;
        byte ba[] = null;
        byte h4[] = null;
        int segsx = 0;
        int segsy = 0;
        double sangle = 0.0;
        boolean manualGoal = this.splinePanel1.isManualGoal();
        double vehicle_width = this.splinePanel1.getVehicleWidth();
        double vehicle_front = this.splinePanel1.getVehicleFront();
        double vehicle_back = this.splinePanel1.getVehicleBack();
        double planner_point_size = this.splinePanel1.getPlannerPointDisplaySize();
        try {

            debugVehicleComm = this.splinePanel1.isDebugVehicleComm();
            this.reconnect();
            this.splinePanel1.incrementDelayReplanCount();
            Socket s = this.socket_to_vehicle;
            OutputStream os = s.getOutputStream();
            InputStream is = s.getInputStream();
            bb = ByteBuffer.allocate(8);
            ba = bb.array();
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort((short) 0x64);
            bb.putShort((short) 8);
            ba = bb.array();
            os.write(bb.array());
            if (debugVehicleComm) {
                System.out.println("Sent:");
                printByteArray(ba);
                System.out.println("");
            }
            h4 = new byte[4];
            bb = ByteBuffer.wrap(h4);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            is.read(h4);
            short type = bb.getShort();
            if (debugVehicleComm) {
                System.out.printf("type = 0x%X\n", type);
            }
            short sz = bb.getShort();
            if (debugVehicleComm) {
                System.out.println("sz = " + sz);
            }
            if (sz < 4) {
                throw new RuntimeException("Bad size value of " + sz);
            }
            ba = new byte[sz - 4];
            is.read(ba);
            bb = ByteBuffer.wrap(ba);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            switch (type) {
                case 0x61:
                    short returnvalue = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("returnvalue = " + returnvalue);
                    }
                    short state = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("state = " + state);
                    }

                    if (sz <= 8) {
                        System.out.println("returnvalue = " + returnvalue);
                        System.out.println("state = " + state);
                        System.out.println("response size too small quitting");
                        break;
                    }
                    if (debugVehicleComm) {
                        System.out.println("Recvd:");
                        printByteArray(h4);
                        printByteArray(ba);
                        System.out.println("");

                    }
                    short segi = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("segi = " + segi);
                    }
                    if (state != 1 || segi == last_sent_seg_id) {
                        setStatusLabel(returnvalue, state, segi);
                        break;
                    }
                    bb.getShort(); // spare
                    segsx = bb.getInt();
                    if (debugVehicleComm) {
                        System.out.println("segsx = " + segsx);
                    }
                    segsy = bb.getInt();
                    if (debugVehicleComm) {
                        System.out.println("segsy = " + segsy);
                    }
                    short segsangle = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("segsangle = " + segsangle);
                    }
                    bb.getShort();
                    int segex = bb.getInt();
                    if (debugVehicleComm) {
                        System.out.println("segex = " + segex);
                    }
                    //bb.getShort();
                    int segey = ((short) (bb.getInt()));
                    if (debugVehicleComm) {
                        System.out.println("segey = " + segey);
                    }
//                        System.out.println("segey = " + segey);
                    //bb.getShort();
                    short segeangle = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("segeangle = " + segeangle);
                    }
                    double segStartLength = this.splinePanel1.getSegStartLength();
                    sangle = Math.toRadians(segsangle / 100.0);
                    double eangle = Math.toRadians(segeangle / 100.0);
                    PlannerInput pi = new PlannerInput();
                    pi.reverse = this.splinePanel1.isReverse();
                    final CarrierState cs0 = new CarrierState(segsx / 10.0,
                            segsy / 10.0,
                            new AngleD(Math.toRadians(segsangle / 100.0)),
                            CarrierStateTypeEnum.START,
                            planner_point_size,
                            vehicle_width,
                            vehicle_front,
                            vehicle_back);
                    if (manualGoal) {
                        List<CarrierState> goalPoints = this.splinePanel1.getGoalPoints();
                        if (goalPoints == null || goalPoints.size() < 1) {
                            if (debugVehicleComm) {
                                System.out.println("No manually set goal point");

                            }
                            setStatusLabel(returnvalue, state, segi);
                            java.awt.EventQueue.invokeLater(new Runnable() {
                                @Override
                                public void run() {
                                    splinePanel1.updatePlannerInfo(cs0, null, null, null);
                                }
                            });
                            break;
                        } else {
                            CarrierState curGoal = goalPoints.get(0);
                            if (null == curGoal) {
                                if (debugVehicleComm) {
                                    System.out.println("null == curGoal");
                                }
                                setStatusLabel(returnvalue, state, segi);

                                java.awt.EventQueue.invokeLater(new Runnable() {
                                    @Override
                                    public void run() {
                                        splinePanel1.updatePlannerInfo(cs0, null, null, null);
                                    }
                                });
                                break;
                            } else if (curGoal.getId() == this.lastGoalId) {
                                if (debugVehicleComm) {
                                    System.out.println("curGoal.getId() (" + curGoal.getId() + ") == lastGoalId");
                                }
                                setStatusLabel(returnvalue, state, segi);
                                curGoal = null;
                                java.awt.EventQueue.invokeLater(new Runnable() {
                                    @Override
                                    public void run() {
                                        splinePanel1.updatePlannerInfo(cs0, null, null, null);
                                    }
                                });
                                break;
                            } else {
                                segex = (short) (curGoal.x * 10.0);
                                segey = (short) (curGoal.y * 10.0);
                                segeangle = (short) (Math.toDegrees(curGoal.getAngle().getValue()) * 100.0);
                                eangle = Math.toRadians(segeangle / 100.0);
                            }
                        }
                    }
                    Point2Dd spt = new Point2Dd(segsx / 10.0, segsy / 10.0);
                    Point2Dd ept = new Point2Dd(segex / 10.0, segey / 10.0);
                    Point2Dd end_to_start = ept.diff(spt);
                    if (!pi.crab) {
                        Point2Dd start_vecu = new Point2Dd(Math.cos(sangle), Math.sin(sangle));
                        Point2Dd end_vecu = new Point2Dd(Math.cos(eangle), Math.sin(eangle));
                        if (!pi.reverse && start_vecu.dot(end_to_start) < 0 && end_vecu.dot(end_to_start) < 0) {
                            this.splinePanel1.setReverse(true);
                            this.jCheckBoxReverse.setSelected(true);
                            pi.reverse = true;
                        } else if (pi.reverse && start_vecu.dot(end_to_start) > 0 && end_vecu.dot(end_to_start) > 0) {
                            this.splinePanel1.setReverse(false);
                            this.jCheckBoxReverse.setSelected(false);
                            pi.reverse = false;
                        }
                    }
                    if (!pi.crab && pi.reverse) {
                        segStartLength = -1.0 * segStartLength;
                    }
                    if (pi.crab) {
                        sangle = Math.atan2(end_to_start.y, end_to_start.x);
                    }
                    final CarrierState csStart = new CarrierState(segsx / 10.0 + segStartLength * Math.cos(sangle),
                            segsy / 10.0 + segStartLength * Math.sin(sangle),
                            new AngleD(Math.toRadians(segsangle / 100.0)),
                            CarrierStateTypeEnum.START,
                            planner_point_size,
                            vehicle_width,
                            vehicle_front,
                            vehicle_back);

                    if (pi.crab) {
                        eangle = Math.atan2(end_to_start.y, end_to_start.y);
                    }
                    final CarrierState csEnd = new CarrierState(segex / 10.0 - segStartLength * Math.cos(eangle),
                            segey / 10.0 - segStartLength * Math.sin(eangle),
                            new AngleD(eangle),
                            CarrierStateTypeEnum.GOAL,
                            planner_point_size,
                            vehicle_width,
                            vehicle_front,
                            vehicle_back);
//                    final CarrierState csg = new CarrierState(segex / 10.0,
//                            segey / 10.0,
//                            new AngleD(eangle),
//                            CarrierStateTypeEnum.GOAL,
//                            planner_point_size,
//                            vehicle_width,
//                            vehicle_front,
//                            vehicle_back);
                    csStart.setGoal(csEnd);
                    Point2Dd goalToLastGoal = null;
                    if (null != lastGoal) {
                        goalToLastGoal = csEnd.diff(lastGoal);
                    }
                    if (manualGoal && end_to_start.mag() < 10.0) {
                        if (debugVehicleComm) {
                            System.out.println("end_to_start.mag() = " + end_to_start.mag());
                        }
                        setStatusLabel(returnvalue, state, segi);
                        java.awt.EventQueue.invokeLater(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(csStart, null, null, null);
                            }
                        });
                        break;
                    }
                    if (manualGoal && goalToLastGoal != null && goalToLastGoal.mag() < 10.0) {
                        if (debugVehicleComm) {
                            System.out.println("startToLastGoal = " + goalToLastGoal);
                            System.out.println("startToLastGoal.mag() = " + end_to_start.mag());
                        }
                        setStatusLabel(returnvalue, state, segi);
                        java.awt.EventQueue.invokeLater(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(cs0, null, null, null);
//                            DisconnectFromVehicle();
//                            jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
//                            int c = JOptionPane.showConfirmDialog(jf, "Spline sent. Send another?");
//                            if(c == JOptionPane.YES_OPTION) {
//                                ConnectToVehicle();
//                                jCheckBoxMenuItemConnectedToVehicle.setSelected(true);
//                            }
                            }
                        });
                        break;
                    }

                    pi.back = vehicle_back;
                    pi.front = vehicle_front;
                    pi.boundaries = this.splinePanel1.getBoundaries();
                    pi.obstacles = this.splinePanel1.getObstacles();
                    pi.crab = this.splinePanel1.isCrab();

                    pi.goal = csEnd;
                    pi.start = csStart;
                    pi.path_uncertainty = this.splinePanel1.getPathUncertainty();
                    pi.veh_width = this.splinePanel1.getVehicleWidth();
                    pi.max_pt2pt_dist = this.splinePanel1.getMax_pt2pt_dist();
                    pi.plannerResolution = this.splinePanel1.getPlannerResolution();
                    pi.max_cntrl_pts = 15;
                    double start_to_goal_dist = pi.start.distance(pi.goal);
                    if (pi.max_pt2pt_dist < start_to_goal_dist / 7.0) {
                        pi.max_pt2pt_dist = start_to_goal_dist / 7.0;
                        System.out.println("pi.max_pt2pt_dist = " + pi.max_pt2pt_dist);
                    }
                    final List<PlannerPoint> planner_list = Planner.createPlannerList(pi, null, null);
                    final List<PlannerPoint> cntrlPts = Planner.planWithPlannerList(pi, planner_list);
                    boolean sendCtrlPtsOk = false;
                    if (null != cntrlPts && cntrlPts.size() > 0) {
                        short speed_mm_s = 500;
                        if (pi.reverse && !pi.crab) {
                            speed_mm_s = (short) -500;
                        }
                        sendCtrlPtsOk =
                                sendCtrlPtsOk = sendControlPoints(s, cntrlPts, pi.crab,
                                segsx, segsy, segsangle,
                                segex, segey, segeangle,
                                segi,
                                speed_mm_s);
//                        if (!sendCtrlPtsOk) {
//                            sendCtrlPtsOk = sendControlPoints(os,
//                                    Arrays.asList(csStart, csEnd),
//                                    segsangle,
//                                    segeangle,
//                                    (short) 200);
//                            if (!sendCtrlPtsOk) {
//                                throw new RuntimeException("Can't send control points.");
//                            }
//                        }
//                        if (!sendCtrlPtsOk) {
//                            throw new RuntimeException("Can't send control points.");
//                        }
                    }
                    os.close();
                    is.close();
                    s.close();
                    this.socket_to_vehicle.close();
                    this.socket_to_vehicle = null;
                    if (sendCtrlPtsOk) {
                        last_sent_seg_id = segi;
                        saveControlPoints(cntrlPts);
                        saveSplinePoints(BSplineCreator.createBSpline(
                                this.splinePanel1.getMinCurveIterations(),
                                this.splinePanel1.getMaxCurveIterations(),
                                this.splinePanel1.getCurveIterationDist(),
                                cntrlPts));
                        lastGoal = new Point2Dd(csEnd.x, csEnd.y);
                        lastGoalId = csEnd.getId();
                        csEnd.getId();
                    }
                    final JFrame jf = this;
                    java.awt.EventQueue.invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            splinePanel1.updatePlannerInfo(csStart, csEnd, planner_list, cntrlPts);
//                            DisconnectFromVehicle();
//                            jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
//                            int c = JOptionPane.showConfirmDialog(jf, "Spline sent. Send another?");
//                            if(c == JOptionPane.YES_OPTION) {
//                                ConnectToVehicle();
//                                jCheckBoxMenuItemConnectedToVehicle.setSelected(true);
//                            }
                        }
                    });

                    return false;

                case 0x65:
                    System.err.println("Error message recieved.");
                    this.DisconnectFromVehicle();
                    this.jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
                    break;

                default:
                    System.err.println("Unrecognized message type:" + type);
                    break;
            }
        } catch (InterruptedException ie) {
            throw ie;
        } catch (Exception e) {
            System.err.println("bb=" + bb);
            e.printStackTrace();
            final Component c = this;
            final String s = e.getMessage();
            if (null != ba) {
                System.out.println("ba:");
                printByteArray(ba);
            }
            if (null != h4) {
                System.out.println("h4:");
                printByteArray(h4);
            }
            final CarrierState cs0 = new CarrierState(segsx / 10.0,
                    segsy / 10.0,
                    new AngleD(sangle),
                    CarrierStateTypeEnum.START,
                    planner_point_size,
                    vehicle_width,
                    vehicle_front,
                    vehicle_back);
            java.awt.EventQueue.invokeLater(new Runnable() {
                @Override
                public void run() {
                    DisconnectFromVehicle();
                    if (ask(s + " :  Retry?")) {
                        if (splinePanel1.isManualGoal()) {
                            if (ask("Clear manual goal?")) {
                                splinePanel1.updatePlannerInfo(cs0, null, null, null);
                            }
                        }
                        ConnectToVehicle();
                    }
                }
            });
        }
        this.splinePanel1.decrementDelayReplanCount();
        return false;
    }

    public boolean ask(final String query) {
        return (JOptionPane.showConfirmDialog(this, this.getTitle() + " : " + query, query, JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION);
    }
    SocketAddress vehicleAddress = new InetSocketAddress("192.168.160.3", 4000);

    private void reconnect() throws Exception {
        if (null != this.socket_to_vehicle
                && this.socket_to_vehicle.isConnected()) {
            return;
        }
        this.socket_to_vehicle = new Socket();
        this.socket_to_vehicle.setReuseAddress(true);
        this.socket_to_vehicle.setSoTimeout(0);
        Thread.sleep(1000);
        this.socket_to_vehicle.connect(vehicleAddress,
                5000);
    }

    public void ConnectToVehicle() {
        try {
            this.last_sent_seg_id = -1;
            this.lastsegid = -1;
            this.jCheckBoxMenuItemReplanOnAllChanges.setSelected(false);
            this.jCheckBoxMenuItemReplanOnAllChanges.setEnabled(false);
            this.splinePanel1.setReplanOnAllChanges(false);
            this.splinePanel1.setConnectedToVehicle(true);
            sendControlPointsCount = 0;
            this.jRadioButtonStart.setEnabled(false);
            if (!this.splinePanel1.isManualGoal()) {
                this.jRadioButtonGoal.setEnabled(false);
                this.jRadioButtonPan.setSelected(true);
                this.splinePanel1.setDrawMode(SplineDrawMode.PAN);
            } else {
                this.jRadioButtonGoal.setEnabled(true);
                this.jRadioButtonGoal.setSelected(true);
                this.splinePanel1.setDrawMode(SplineDrawMode.GOAL);
            }

            this.reconnect();
            if (null == this.socket_to_vehicle || !this.socket_to_vehicle.isConnected()) {
                JOptionPane.showMessageDialog(this, "ConnectToVehicle Failed!");
                this.DisconnectFromVehicle();
                return;
            }
            monitorVehicleThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    MonitorVehicle();
                }
            }, "monitorVehicleThread");
            monitorVehicleThread.start();
            if (!this.jCheckBoxMenuItemConnectedToVehicle.isSelected()) {
                this.jCheckBoxMenuItemConnectedToVehicle.setSelected(true);
            }
        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, "ConnectToVehicle Failed!");
            this.DisconnectFromVehicle();
        }
    }

    public void DisconnectFromVehicle() {
        try {
            this.jCheckBoxMenuItemReplanOnAllChanges.setEnabled(true);
            this.jRadioButtonStart.setEnabled(true);
            this.jRadioButtonGoal.setEnabled(true);
            sendControlPointsCount = 0;
            if (null != this.socket_to_vehicle) {
                this.socket_to_vehicle.close();
                this.socket_to_vehicle = null;
            }
            if (null != this.monitorVehicleThread) {
                this.monitorVehicleThread.interrupt();
                this.monitorVehicleThread.join(5000);
                this.monitorVehicleThread = null;
            }
            if (this.jCheckBoxMenuItemConnectedToVehicle.isSelected()) {
                this.jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
            }
            this.splinePanel1.setConnectedToVehicle(false);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public final void centerDrawPanelViewPort() {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension pref_size = this.splinePanel1.getPreferredSize();
        int center_x = pref_size.width / 2;
        int center_y = pref_size.height / 2;
        Point new_upper_corner = new Point((int) (center_x - rect.width / 2),
                ((int) center_y - rect.height / 2));
        if (new_upper_corner.x < 0) {
            new_upper_corner.x = 0;
        }
        if (new_upper_corner.y < 0) {
            new_upper_corner.y = 0;
        }
        vp.setViewPosition(new_upper_corner);
    }

    public void changeZoom(double scale) {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension old_pref_size = this.splinePanel1.getPreferredSize();
        Dimension new_pref_size = new Dimension(
                (int) Math.max(rect.width, old_pref_size.width * scale),
                (int) Math.max(rect.height, old_pref_size.height * scale));
        this.splinePanel1.setPreferredSize(new_pref_size);
        this.splinePanel1.revalidate();
        this.jScrollPane1.revalidate();
        this.splinePanel1.setZoomScale(this.splinePanel1.getZoomScale() * scale);
        this.repaint();
    }

    /**
     * After zooming or fitting update the JScrollPane's viewport.
     */
    public final void updateDrawPanelViewport(double scale) {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension d = new Dimension();
        d.width = (int) (rect.width * scale);
        d.height = (int) (rect.height * scale);
        Dimension old_pref_size = this.splinePanel1.getPreferredSize();
        this.splinePanel1.setPreferredSize(d);
        this.splinePanel1.setZoomScale((float) scale);
        this.splinePanel1.revalidate();
        this.jScrollPane1.revalidate();
        this.repaint();
        double old_center_x = rect.x + rect.width / 2;
        double old_center_y = rect.y + rect.height / 2;
        double center_x = old_center_x * d.width / ((double) old_pref_size.width);
        double center_y = old_center_y * d.height / ((double) old_pref_size.height);
        Point new_upper_corner = new Point((int) (center_x - rect.width / 2),
                ((int) center_y - rect.height / 2));
        if (new_upper_corner.x < 0) {
            this.splinePanel1.setTranslateX(new_upper_corner.x * this.splinePanel1.getZoomScale());
            new_upper_corner.x = 0;
        } else {
            this.splinePanel1.setTranslateX(0);
        }
        if (new_upper_corner.y < 0) {
            this.splinePanel1.setTranslateY(new_upper_corner.y * this.splinePanel1.getZoomScale());
            new_upper_corner.y = 0;
        } else {
            this.splinePanel1.setTranslateY(0);
        }
        vp.setViewPosition(new_upper_corner);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SplineTestJFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupDrawMode;
    private javax.swing.JButton jButtonClear;
    private javax.swing.JButton jButtonDelete;
    private javax.swing.JButton jButtonFit;
    private javax.swing.JButton jButtonZoomLess;
    private javax.swing.JButton jButtonZoomMore;
    private javax.swing.JCheckBox jCheckBoxCrab;
    private javax.swing.JCheckBox jCheckBoxExclusiveTracks;
    private javax.swing.JCheckBox jCheckBoxLabelControlPoints;
    private javax.swing.JCheckBox jCheckBoxLabelGrid;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemConnectToObsDetect;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemConnectToVehicleManual;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemConnectedToVehicle;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemDebugObsDetComm;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemDebugVehicleComm;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemPlotAllCntlrPts;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemReplanOnAllChanges;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemShowBackground;
    private javax.swing.JCheckBox jCheckBoxReverse;
    private javax.swing.JCheckBox jCheckBoxShowCenterCurve;
    private javax.swing.JCheckBox jCheckBoxShowControlPath;
    private javax.swing.JCheckBox jCheckBoxShowGrid;
    private javax.swing.JCheckBox jCheckBoxShowOutlines;
    private javax.swing.JCheckBox jCheckBoxShowPlanOutline;
    private javax.swing.JCheckBox jCheckBoxShowPlanning;
    private javax.swing.JCheckBox jCheckBoxShowSideCurves;
    private javax.swing.JCheckBox jCheckBoxSimulation;
    private javax.swing.JLabel jLabelStatus;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenuBackground;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenu jMenuChecks;
    private javax.swing.JMenu jMenuConnections;
    private javax.swing.JMenu jMenuImport;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItemChangeFields;
    private javax.swing.JMenuItem jMenuItemClear;
    private javax.swing.JMenuItem jMenuItemDelete;
    private javax.swing.JMenuItem jMenuItemDown;
    private javax.swing.JMenuItem jMenuItemFileOpen;
    private javax.swing.JMenuItem jMenuItemFileSaveAs;
    private javax.swing.JMenuItem jMenuItemForceReplanning;
    private javax.swing.JMenuItem jMenuItemImportDXFBackground;
    private javax.swing.JMenuItem jMenuItemImportDXFBoundaries;
    private javax.swing.JMenuItem jMenuItemLeft;
    private javax.swing.JMenuItem jMenuItemPlotLastCntrlPtsSent;
    private javax.swing.JMenuItem jMenuItemReCheckPath;
    private javax.swing.JMenuItem jMenuItemRight;
    private javax.swing.JMenuItem jMenuItemSetProperty;
    private javax.swing.JMenuItem jMenuItemSwapGoalStart;
    private javax.swing.JMenuItem jMenuItemUp;
    private javax.swing.JMenu jMenuMove;
    private javax.swing.JMenu jMenuRecentFiles;
    private javax.swing.JRadioButton jRadioButtonBoundary;
    private javax.swing.JRadioButton jRadioButtonGoal;
    private javax.swing.JRadioButton jRadioButtonHorzBoundary;
    private javax.swing.JRadioButton jRadioButtonObstacle;
    private javax.swing.JRadioButton jRadioButtonPan;
    private javax.swing.JRadioButton jRadioButtonSelect;
    private javax.swing.JRadioButton jRadioButtonStart;
    private javax.swing.JRadioButton jRadioButtonVertBoundary;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JToolBar.Separator jSeparator1;
    private javax.swing.JToolBar.Separator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JToolBar jToolBar2;
    private splinetest.SplinePanel splinePanel1;
    // End of variables declaration//GEN-END:variables
}
