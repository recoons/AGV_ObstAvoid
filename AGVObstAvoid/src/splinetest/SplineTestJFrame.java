/*
 This is public domain software, however it is preferred
 that the following disclaimers be attached.

 Software Copywrite/Warranty Disclaimer

 This software was developed at the National Institute of Standards and
 Technology by employees of the Federal Government in the course of their
 official duties. Pursuant to title 17 Section 105 of the United States
 Code this software is not subject to copyright protection and is in the
 public domain. This software is experimental. NIST assumes no responsibility
 whatsoever for its use by other parties, and makes no guarantees, expressed
 or implied, aboutc its quality, reliability, or any other characteristic.

 We would appreciate acknowledgement if the software is used. This software can
 be redistributed and/or modified freely provided that any derivative works
 bear some notice that they are derived from it, and any modified
 versions bear some notice that they have been modified.

 */
package splinetest;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.geom.Rectangle2D;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.StringReader;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketAddress;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.text.DateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Vector;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JViewport;
import javax.swing.ProgressMonitor;
import javax.swing.SwingWorker;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 * Main JFrame for containing components that display/draw/select objects in the
 * 2D world include vehicles, obstacles, boundaries and planned splines.
 *
 * @author Will Shackleford<shackle@nist.gov>
 */
public class SplineTestJFrame extends javax.swing.JFrame {

    /**
     * Creates new form SplineTestJFrame
     */
    public SplineTestJFrame() {
        initComponents();
        this.centerDrawPanelViewPort();
        this.loadRecentFiles();
        Planner.statusSetter = new PlannerStatusSetter() {
            @Override
            public void setPlannerStatus(final String s) {
                java.awt.EventQueue.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        jLabelPlannerStatus.setText(s);
                    }
                });
            }
        };
        this.updateAngle();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        buttonGroupDrawMode = new javax.swing.ButtonGroup();
        jSeparator3 = new javax.swing.JSeparator();
        buttonGroupGoalSource = new javax.swing.ButtonGroup();
        jScrollPane1 = new javax.swing.JScrollPane();
        splinePanel1 = new splinetest.SplinePanel();
        jToolBar1 = new javax.swing.JToolBar();
        jButtonClear = new javax.swing.JButton();
        jSeparator1 = new javax.swing.JToolBar.Separator();
        jRadioButtonStart = new javax.swing.JRadioButton();
        jRadioButtonGoal = new javax.swing.JRadioButton();
        jRadioButtonWaypoint = new javax.swing.JRadioButton();
        jRadioButtonObstacle = new javax.swing.JRadioButton();
        jRadioButtonSelect = new javax.swing.JRadioButton();
        jRadioButtonBoundary = new javax.swing.JRadioButton();
        jRadioButtonHorzBoundary = new javax.swing.JRadioButton();
        jRadioButtonVertBoundary = new javax.swing.JRadioButton();
        jRadioButtonPan = new javax.swing.JRadioButton();
        jRadioButtonDrawPlanningRect = new javax.swing.JRadioButton();
        jSeparator2 = new javax.swing.JToolBar.Separator();
        jButtonZoomMore = new javax.swing.JButton();
        jButtonZoomLess = new javax.swing.JButton();
        jButtonFit = new javax.swing.JButton();
        jButtonDelete = new javax.swing.JButton();
        jToolBar2 = new javax.swing.JToolBar();
        jCheckBoxShowPlanning = new javax.swing.JCheckBox();
        jCheckBoxCrab = new javax.swing.JCheckBox();
        jCheckBoxReverse = new javax.swing.JCheckBox();
        jCheckBoxIgnoreBoundaries = new javax.swing.JCheckBox();
        jCheckBoxShowOutlines = new javax.swing.JCheckBox();
        jCheckBoxShowControlPath = new javax.swing.JCheckBox();
        jCheckBoxLabelControlPoints = new javax.swing.JCheckBox();
        jCheckBoxShowGrid = new javax.swing.JCheckBox();
        jCheckBoxLabelGrid = new javax.swing.JCheckBox();
        jCheckBoxSimulation = new javax.swing.JCheckBox();
        jCheckBoxShowPlanOutline = new javax.swing.JCheckBox();
        jLabelVehicleStatus = new javax.swing.JLabel();
        jLabelPlannerStatus = new javax.swing.JLabel();
        jToolBar3 = new javax.swing.JToolBar();
        jCheckBoxExclusiveTracks = new javax.swing.JCheckBox();
        jCheckBoxShowCenterCurve = new javax.swing.JCheckBox();
        jCheckBoxShowSideCurves = new javax.swing.JCheckBox();
        jLabelAngle = new javax.swing.JLabel();
        jButtonModifyAngle = new javax.swing.JButton();
        jButtonUp = new javax.swing.JButton();
        jButtonDown = new javax.swing.JButton();
        jButtonLeft = new javax.swing.JButton();
        jButtonRight = new javax.swing.JButton();
        jButtonSendManualGoal = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItemFileSaveAs = new javax.swing.JMenuItem();
        jMenuItemFileOpen = new javax.swing.JMenuItem();
        jMenuRecentFiles = new javax.swing.JMenu();
        jMenuImport = new javax.swing.JMenu();
        jMenuItemImportDXFBackground = new javax.swing.JMenuItem();
        jMenuItemImportDXFBoundaries = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenuItemClear = new javax.swing.JMenuItem();
        jMenuItemChangeFields = new javax.swing.JMenuItem();
        jMenuItemSetProperty = new javax.swing.JMenuItem();
        jMenuItemDelete = new javax.swing.JMenuItem();
        jMenuMove = new javax.swing.JMenu();
        jMenuItemUp = new javax.swing.JMenuItem();
        jMenuItemDown = new javax.swing.JMenuItem();
        jMenuItemLeft = new javax.swing.JMenuItem();
        jMenuItemRight = new javax.swing.JMenuItem();
        jMenuConnections = new javax.swing.JMenu();
        jCheckBoxMenuItemConnectedToVehicle = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemDebugVehicleComm = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemConnectToObsDetect = new javax.swing.JCheckBoxMenuItem();
        jCheckBoxMenuItemDebugObsDetComm = new javax.swing.JCheckBoxMenuItem();
        jSeparator4 = new javax.swing.JPopupMenu.Separator();
        jRadioButtonMenuItemGoalFromConnection = new javax.swing.JRadioButtonMenuItem();
        jRadioButtonMenuItemManualGoal = new javax.swing.JRadioButtonMenuItem();
        jRadioButtonMenuItemGoalFromWaypoints = new javax.swing.JRadioButtonMenuItem();
        jCheckBoxMenuItemConfirmControlPoints = new javax.swing.JCheckBoxMenuItem();
        jMenuChecks = new javax.swing.JMenu();
        jMenuItemReCheckPath = new javax.swing.JMenuItem();
        jMenuItemForceReplanning = new javax.swing.JMenuItem();
        jCheckBoxMenuItemReplanOnAllChanges = new javax.swing.JCheckBoxMenuItem();
        jMenuItemSwapGoalStart = new javax.swing.JMenuItem();
        jMenuItemPlotLastCntrlPtsSent = new javax.swing.JMenuItem();
        jCheckBoxMenuItemPlotAllCntlrPts = new javax.swing.JCheckBoxMenuItem();
        jMenuItemPlotSplinesWithControlPoints = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();
        jMenuItemPlotCurveRadius = new javax.swing.JMenuItem();
        jMenuItemTestPlanningParam = new javax.swing.JMenuItem();
        jCheckBoxMenuItemRecordPlannerStats = new javax.swing.JCheckBoxMenuItem();
        jMenuItemPlotRecordedPlannerStats = new javax.swing.JMenuItem();
        jMenuItemTestAllPositons = new javax.swing.JMenuItem();
        jMenuBackground = new javax.swing.JMenu();
        jCheckBoxMenuItemShowBackground = new javax.swing.JCheckBoxMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenuOptions = new javax.swing.JMenu();
        jCheckBoxMenuItemStaticPlannerList = new javax.swing.JCheckBoxMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("AGV Obstacle Avoidance Spline Planning");
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });
        addWindowStateListener(new java.awt.event.WindowStateListener() {
            public void windowStateChanged(java.awt.event.WindowEvent evt) {
                formWindowStateChanged(evt);
            }
        });

        splinePanel1.setPreferredSize(new java.awt.Dimension(2000, 2000));

        javax.swing.GroupLayout splinePanel1Layout = new javax.swing.GroupLayout(splinePanel1);
        splinePanel1.setLayout(splinePanel1Layout);
        splinePanel1Layout.setHorizontalGroup(
            splinePanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2000, Short.MAX_VALUE)
        );
        splinePanel1Layout.setVerticalGroup(
            splinePanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 2000, Short.MAX_VALUE)
        );

        jScrollPane1.setViewportView(splinePanel1);

        jToolBar1.setFloatable(false);
        jToolBar1.setRollover(true);

        jButtonClear.setText("Clear");
        jButtonClear.setFocusable(false);
        jButtonClear.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonClear.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonClear);
        jToolBar1.add(jSeparator1);

        buttonGroupDrawMode.add(jRadioButtonStart);
        jRadioButtonStart.setSelected(true);
        jRadioButtonStart.setText(" Start ");
        jRadioButtonStart.setFocusable(false);
        jRadioButtonStart.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonStart.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonStartActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonStart);

        buttonGroupDrawMode.add(jRadioButtonGoal);
        jRadioButtonGoal.setText(" Goal ");
        jRadioButtonGoal.setFocusable(false);
        jRadioButtonGoal.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonGoal.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonGoal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonGoalActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonGoal);

        buttonGroupDrawMode.add(jRadioButtonWaypoint);
        jRadioButtonWaypoint.setText(" Waypoint ");
        jRadioButtonWaypoint.setFocusable(false);
        jRadioButtonWaypoint.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonWaypoint.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonWaypoint.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonWaypointActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonWaypoint);

        buttonGroupDrawMode.add(jRadioButtonObstacle);
        jRadioButtonObstacle.setText(" Obstacle ");
        jRadioButtonObstacle.setFocusable(false);
        jRadioButtonObstacle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonObstacle.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonObstacle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonObstacleActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonObstacle);

        buttonGroupDrawMode.add(jRadioButtonSelect);
        jRadioButtonSelect.setText(" Select ");
        jRadioButtonSelect.setFocusable(false);
        jRadioButtonSelect.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonSelect.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonSelect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonSelectActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonSelect);

        buttonGroupDrawMode.add(jRadioButtonBoundary);
        jRadioButtonBoundary.setText(" Boundary ");
        jRadioButtonBoundary.setFocusable(false);
        jRadioButtonBoundary.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonBoundary.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonBoundary.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonBoundaryActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonBoundary);

        buttonGroupDrawMode.add(jRadioButtonHorzBoundary);
        jRadioButtonHorzBoundary.setText(" Horz. Boundary ");
        jRadioButtonHorzBoundary.setFocusable(false);
        jRadioButtonHorzBoundary.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonHorzBoundary.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonHorzBoundary.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonHorzBoundaryActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonHorzBoundary);

        buttonGroupDrawMode.add(jRadioButtonVertBoundary);
        jRadioButtonVertBoundary.setText(" Vert. Boundary ");
        jRadioButtonVertBoundary.setFocusable(false);
        jRadioButtonVertBoundary.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonVertBoundary.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonVertBoundary.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonVertBoundaryActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonVertBoundary);

        buttonGroupDrawMode.add(jRadioButtonPan);
        jRadioButtonPan.setText(" Pan ");
        jRadioButtonPan.setFocusable(false);
        jRadioButtonPan.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonPan.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonPan.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonPanActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonPan);

        buttonGroupDrawMode.add(jRadioButtonDrawPlanningRect);
        jRadioButtonDrawPlanningRect.setText(" Draw Planning Rect. ");
        jRadioButtonDrawPlanningRect.setFocusable(false);
        jRadioButtonDrawPlanningRect.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jRadioButtonDrawPlanningRect.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jRadioButtonDrawPlanningRect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonDrawPlanningRectActionPerformed(evt);
            }
        });
        jToolBar1.add(jRadioButtonDrawPlanningRect);
        jToolBar1.add(jSeparator2);

        jButtonZoomMore.setText(" Zoom + ");
        jButtonZoomMore.setFocusable(false);
        jButtonZoomMore.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonZoomMore.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonZoomMore.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonZoomMoreActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonZoomMore);

        jButtonZoomLess.setText(" Zoom - ");
        jButtonZoomLess.setFocusable(false);
        jButtonZoomLess.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonZoomLess.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonZoomLess.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonZoomLessActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonZoomLess);

        jButtonFit.setText(" Fit ");
        jButtonFit.setFocusable(false);
        jButtonFit.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonFit.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonFit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonFitActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonFit);

        jButtonDelete.setText(" Delete ");
        jButtonDelete.setFocusable(false);
        jButtonDelete.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonDelete.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDeleteActionPerformed(evt);
            }
        });
        jToolBar1.add(jButtonDelete);

        jToolBar2.setFloatable(false);
        jToolBar2.setRollover(true);

        jCheckBoxShowPlanning.setText("Show Planning");
        jCheckBoxShowPlanning.setFocusable(false);
        jCheckBoxShowPlanning.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowPlanning.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowPlanning.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowPlanningActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowPlanning);

        jCheckBoxCrab.setText(" Crab ");
        jCheckBoxCrab.setFocusable(false);
        jCheckBoxCrab.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxCrab.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxCrab.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxCrabActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxCrab);

        jCheckBoxReverse.setText(" Reverse ");
        jCheckBoxReverse.setFocusable(false);
        jCheckBoxReverse.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxReverse.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxReverse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxReverseActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxReverse);

        jCheckBoxIgnoreBoundaries.setText(" Ignore Boundaries ");
        jCheckBoxIgnoreBoundaries.setFocusable(false);
        jCheckBoxIgnoreBoundaries.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxIgnoreBoundaries.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxIgnoreBoundaries.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxIgnoreBoundariesActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxIgnoreBoundaries);

        jCheckBoxShowOutlines.setSelected(true);
        jCheckBoxShowOutlines.setText(" Show Outlines ");
        jCheckBoxShowOutlines.setFocusable(false);
        jCheckBoxShowOutlines.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowOutlines.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowOutlines.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowOutlinesActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowOutlines);

        jCheckBoxShowControlPath.setText(" Show Control Path ");
        jCheckBoxShowControlPath.setFocusable(false);
        jCheckBoxShowControlPath.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowControlPath.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowControlPath.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowControlPathActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowControlPath);

        jCheckBoxLabelControlPoints.setText(" Label Points ");
        jCheckBoxLabelControlPoints.setFocusable(false);
        jCheckBoxLabelControlPoints.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxLabelControlPoints.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxLabelControlPoints.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxLabelControlPointsActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxLabelControlPoints);

        jCheckBoxShowGrid.setText(" Show Grid ");
        jCheckBoxShowGrid.setFocusable(false);
        jCheckBoxShowGrid.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowGrid.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowGrid.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowGridActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowGrid);

        jCheckBoxLabelGrid.setText(" Label Grid ");
        jCheckBoxLabelGrid.setFocusable(false);
        jCheckBoxLabelGrid.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxLabelGrid.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxLabelGrid.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxLabelGridActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxLabelGrid);

        jCheckBoxSimulation.setText(" Simulation ");
        jCheckBoxSimulation.setFocusable(false);
        jCheckBoxSimulation.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxSimulation.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxSimulation.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxSimulationActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxSimulation);

        jCheckBoxShowPlanOutline.setText(" Show Plan  Exclusion Outline ");
        jCheckBoxShowPlanOutline.setFocusable(false);
        jCheckBoxShowPlanOutline.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowPlanOutline.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowPlanOutline.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowPlanOutlineActionPerformed(evt);
            }
        });
        jToolBar2.add(jCheckBoxShowPlanOutline);

        jLabelVehicleStatus.setText("Vehicle Status:");

        jLabelPlannerStatus.setText("Plan : ");

        jToolBar3.setFloatable(false);
        jToolBar3.setRollover(true);

        jCheckBoxExclusiveTracks.setText(" Exclusive Tracks");
        jCheckBoxExclusiveTracks.setFocusable(false);
        jCheckBoxExclusiveTracks.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxExclusiveTracks.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxExclusiveTracks.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxExclusiveTracksActionPerformed(evt);
            }
        });
        jToolBar3.add(jCheckBoxExclusiveTracks);

        jCheckBoxShowCenterCurve.setSelected(true);
        jCheckBoxShowCenterCurve.setText(" Show Center Curve ");
        jCheckBoxShowCenterCurve.setFocusable(false);
        jCheckBoxShowCenterCurve.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowCenterCurve.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowCenterCurve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowCenterCurveActionPerformed(evt);
            }
        });
        jToolBar3.add(jCheckBoxShowCenterCurve);

        jCheckBoxShowSideCurves.setText(" Show Side Curves ");
        jCheckBoxShowSideCurves.setFocusable(false);
        jCheckBoxShowSideCurves.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jCheckBoxShowSideCurves.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxShowSideCurves.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxShowSideCurvesActionPerformed(evt);
            }
        });
        jToolBar3.add(jCheckBoxShowSideCurves);

        jLabelAngle.setText(" Angle (in degrees):  90.0 ");
        jToolBar3.add(jLabelAngle);

        jButtonModifyAngle.setText("Modify Angle");
        jButtonModifyAngle.setFocusable(false);
        jButtonModifyAngle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonModifyAngle.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonModifyAngle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonModifyAngleActionPerformed(evt);
            }
        });
        jToolBar3.add(jButtonModifyAngle);

        jButtonUp.setText("Up");
        jButtonUp.setFocusable(false);
        jButtonUp.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonUp.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonUp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonUpActionPerformed(evt);
            }
        });
        jToolBar3.add(jButtonUp);

        jButtonDown.setText("Down");
        jButtonDown.setFocusable(false);
        jButtonDown.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonDown.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonDown.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonDownActionPerformed(evt);
            }
        });
        jToolBar3.add(jButtonDown);

        jButtonLeft.setText("Left");
        jButtonLeft.setFocusable(false);
        jButtonLeft.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonLeft.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonLeft.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonLeftActionPerformed(evt);
            }
        });
        jToolBar3.add(jButtonLeft);

        jButtonRight.setText("Right");
        jButtonRight.setFocusable(false);
        jButtonRight.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonRight.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonRight.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRightActionPerformed(evt);
            }
        });
        jToolBar3.add(jButtonRight);

        jButtonSendManualGoal.setText(" Send Manual Goal ");
        jButtonSendManualGoal.setEnabled(false);
        jButtonSendManualGoal.setFocusable(false);
        jButtonSendManualGoal.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jButtonSendManualGoal.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jButtonSendManualGoal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonSendManualGoalActionPerformed(evt);
            }
        });
        jToolBar3.add(jButtonSendManualGoal);

        jMenu1.setText("File");

        jMenuItemFileSaveAs.setText("Save As ....");
        jMenuItemFileSaveAs.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemFileSaveAsActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemFileSaveAs);

        jMenuItemFileOpen.setText("Open ...");
        jMenuItemFileOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemFileOpenActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItemFileOpen);

        jMenuRecentFiles.setText("Recent Files");
        jMenu1.add(jMenuRecentFiles);

        jMenuImport.setText("Import");

        jMenuItemImportDXFBackground.setText("Import Shapes from DXF as Background ...");
        jMenuItemImportDXFBackground.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemImportDXFBackgroundActionPerformed(evt);
            }
        });
        jMenuImport.add(jMenuItemImportDXFBackground);

        jMenuItemImportDXFBoundaries.setText("Import Lines From DXF as Boundaries ...");
        jMenuItemImportDXFBoundaries.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemImportDXFBoundariesActionPerformed(evt);
            }
        });
        jMenuImport.add(jMenuItemImportDXFBoundaries);

        jMenu1.add(jMenuImport);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");

        jMenuItemClear.setText("Clear");
        jMenuItemClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemClearActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemClear);

        jMenuItemChangeFields.setText("Change AGV Frame/Slow/Stop Fields");
        jMenu2.add(jMenuItemChangeFields);

        jMenuItemSetProperty.setText("Set Property ...");
        jMenuItemSetProperty.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSetPropertyActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemSetProperty);

        jMenuItemDelete.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DELETE, 0));
        jMenuItemDelete.setText("Delete Selection");
        jMenuItemDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemDeleteActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItemDelete);

        jMenuBar1.add(jMenu2);

        jMenuMove.setText("Move");
        jMenuMove.setEnabled(false);

        jMenuItemUp.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_UP, 0));
        jMenuItemUp.setText("Up");
        jMenuItemUp.setEnabled(false);
        jMenuItemUp.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemUpActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemUp);

        jMenuItemDown.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_DOWN, 0));
        jMenuItemDown.setText("Down");
        jMenuItemDown.setEnabled(false);
        jMenuItemDown.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemDownActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemDown);

        jMenuItemLeft.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_LEFT, 0));
        jMenuItemLeft.setText("Left");
        jMenuItemLeft.setEnabled(false);
        jMenuItemLeft.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemLeftActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemLeft);

        jMenuItemRight.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_RIGHT, 0));
        jMenuItemRight.setText("Right");
        jMenuItemRight.setEnabled(false);
        jMenuItemRight.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemRightActionPerformed(evt);
            }
        });
        jMenuMove.add(jMenuItemRight);

        jMenuBar1.add(jMenuMove);

        jMenuConnections.setText("Connections");

        jCheckBoxMenuItemConnectedToVehicle.setText("Connect to Vehicle");
        jCheckBoxMenuItemConnectedToVehicle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemConnectedToVehicleActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemConnectedToVehicle);

        jCheckBoxMenuItemDebugVehicleComm.setSelected(true);
        jCheckBoxMenuItemDebugVehicleComm.setText("Debug Vehicle Comm");
        jCheckBoxMenuItemDebugVehicleComm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemDebugVehicleCommActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemDebugVehicleComm);

        jCheckBoxMenuItemConnectToObsDetect.setText("Connect to Obstacle Detection");
        jCheckBoxMenuItemConnectToObsDetect.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemConnectToObsDetectActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemConnectToObsDetect);

        jCheckBoxMenuItemDebugObsDetComm.setSelected(true);
        jCheckBoxMenuItemDebugObsDetComm.setText("Debug Obstacle Detect Comm");
        jCheckBoxMenuItemDebugObsDetComm.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemDebugObsDetCommActionPerformed(evt);
            }
        });
        jMenuConnections.add(jCheckBoxMenuItemDebugObsDetComm);
        jMenuConnections.add(jSeparator4);

        buttonGroupGoalSource.add(jRadioButtonMenuItemGoalFromConnection);
        jRadioButtonMenuItemGoalFromConnection.setSelected(true);
        jRadioButtonMenuItemGoalFromConnection.setText("Get Vehicle Goal From Connection");
        jRadioButtonMenuItemGoalFromConnection.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonMenuItemGoalFromConnectionActionPerformed(evt);
            }
        });
        jMenuConnections.add(jRadioButtonMenuItemGoalFromConnection);

        buttonGroupGoalSource.add(jRadioButtonMenuItemManualGoal);
        jRadioButtonMenuItemManualGoal.setText("Get Vehicle Goal Manually");
        jRadioButtonMenuItemManualGoal.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonMenuItemManualGoalActionPerformed(evt);
            }
        });
        jMenuConnections.add(jRadioButtonMenuItemManualGoal);

        buttonGroupGoalSource.add(jRadioButtonMenuItemGoalFromWaypoints);
        jRadioButtonMenuItemGoalFromWaypoints.setText("Get Vehicle Goal from Existing Waypoints");
        jRadioButtonMenuItemGoalFromWaypoints.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRadioButtonMenuItemGoalFromWaypointsActionPerformed(evt);
            }
        });
        jMenuConnections.add(jRadioButtonMenuItemGoalFromWaypoints);

        jCheckBoxMenuItemConfirmControlPoints.setSelected(true);
        jCheckBoxMenuItemConfirmControlPoints.setText("Confirm Control Points?");
        jMenuConnections.add(jCheckBoxMenuItemConfirmControlPoints);

        jMenuBar1.add(jMenuConnections);

        jMenuChecks.setText("Checks");

        jMenuItemReCheckPath.setText("Re-Check Path");
        jMenuItemReCheckPath.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemReCheckPathActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemReCheckPath);

        jMenuItemForceReplanning.setText("Force replanning");
        jMenuItemForceReplanning.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemForceReplanningActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemForceReplanning);

        jCheckBoxMenuItemReplanOnAllChanges.setSelected(true);
        jCheckBoxMenuItemReplanOnAllChanges.setText("Replan on all changes");
        jCheckBoxMenuItemReplanOnAllChanges.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemReplanOnAllChangesActionPerformed(evt);
            }
        });
        jMenuChecks.add(jCheckBoxMenuItemReplanOnAllChanges);

        jMenuItemSwapGoalStart.setText("Swap Goal/Start");
        jMenuItemSwapGoalStart.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSwapGoalStartActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemSwapGoalStart);

        jMenuItemPlotLastCntrlPtsSent.setText("Plot Last Contrl Pts Sent");
        jMenuItemPlotLastCntrlPtsSent.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemPlotLastCntrlPtsSentActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemPlotLastCntrlPtsSent);

        jCheckBoxMenuItemPlotAllCntlrPts.setSelected(true);
        jCheckBoxMenuItemPlotAllCntlrPts.setText("Plot All Contrl Pts Sent");
        jCheckBoxMenuItemPlotAllCntlrPts.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed(evt);
            }
        });
        jMenuChecks.add(jCheckBoxMenuItemPlotAllCntlrPts);

        jMenuItemPlotSplinesWithControlPoints.setText("Plot Splines");
        jMenuItemPlotSplinesWithControlPoints.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemPlotSplinesWithControlPointsActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemPlotSplinesWithControlPoints);

        jMenuItem2.setText("Plot Splines with Control Points");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItem2);

        jMenuItemPlotCurveRadius.setText("Plot Curve Radius");
        jMenuItemPlotCurveRadius.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemPlotCurveRadiusActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemPlotCurveRadius);

        jMenuItemTestPlanningParam.setText("Test Planning Parameter over Range");
        jMenuItemTestPlanningParam.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemTestPlanningParamActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemTestPlanningParam);

        jCheckBoxMenuItemRecordPlannerStats.setText("Record Planner Stats");
        jCheckBoxMenuItemRecordPlannerStats.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemRecordPlannerStatsActionPerformed(evt);
            }
        });
        jMenuChecks.add(jCheckBoxMenuItemRecordPlannerStats);

        jMenuItemPlotRecordedPlannerStats.setText("Plot Recorded Planner Stats");
        jMenuItemPlotRecordedPlannerStats.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemPlotRecordedPlannerStatsActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemPlotRecordedPlannerStats);

        jMenuItemTestAllPositons.setText("Test All Positions");
        jMenuItemTestAllPositons.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemTestAllPositonsActionPerformed(evt);
            }
        });
        jMenuChecks.add(jMenuItemTestAllPositons);

        jMenuBar1.add(jMenuChecks);

        jMenuBackground.setText("Background");

        jCheckBoxMenuItemShowBackground.setSelected(true);
        jCheckBoxMenuItemShowBackground.setText("Show Background");
        jCheckBoxMenuItemShowBackground.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemShowBackgroundActionPerformed(evt);
            }
        });
        jMenuBackground.add(jCheckBoxMenuItemShowBackground);

        jMenuItem1.setText("Clear");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenuBackground.add(jMenuItem1);

        jMenuBar1.add(jMenuBackground);

        jMenuOptions.setText("Options");

        jCheckBoxMenuItemStaticPlannerList.setSelected(true);
        jCheckBoxMenuItemStaticPlannerList.setText("Static Planner List");
        jCheckBoxMenuItemStaticPlannerList.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemStaticPlannerListActionPerformed(evt);
            }
        });
        jMenuOptions.add(jCheckBoxMenuItemStaticPlannerList);

        jMenuBar1.add(jMenuOptions);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE))
                    .addComponent(jLabelVehicleStatus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jLabelPlannerStatus, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jToolBar2, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(jToolBar3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addComponent(jToolBar1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jToolBar2, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jToolBar3, javax.swing.GroupLayout.PREFERRED_SIZE, 40, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabelPlannerStatus)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabelVehicleStatus, javax.swing.GroupLayout.PREFERRED_SIZE, 21, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 302, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void Clear() {
        this.jCheckBoxSimulation.setSelected(false);
        this.jCheckBoxShowOutlines.setEnabled(true);
        this.splinePanel1.Clear();
    }

    private void jMenuItemClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemClearActionPerformed
        this.Clear();
    }//GEN-LAST:event_jMenuItemClearActionPerformed

    private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
        this.Clear();
    }//GEN-LAST:event_jButtonClearActionPerformed

    private void setMoveEnabled(boolean _enabled) {
        this.jMenuMove.setEnabled(_enabled);
        this.jMenuItemUp.setEnabled(_enabled);
        this.jMenuItemDown.setEnabled(_enabled);
        this.jMenuItemLeft.setEnabled(_enabled);
        this.jMenuItemRight.setEnabled(_enabled);
    }

    private void jRadioButtonStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonStartActionPerformed
        if (this.jRadioButtonStart.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.START);
            this.setMoveEnabled(false);
        }
        this.updateAngle();
    }//GEN-LAST:event_jRadioButtonStartActionPerformed

    private void jRadioButtonGoalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonGoalActionPerformed
        if (this.jRadioButtonGoal.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.GOAL);
            this.setMoveEnabled(false);
        }
        this.updateAngle();
    }//GEN-LAST:event_jRadioButtonGoalActionPerformed

    private void jRadioButtonObstacleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonObstacleActionPerformed
        if (this.jRadioButtonObstacle.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.OBSTACLE);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonObstacleActionPerformed

    private void jCheckBoxShowPlanningActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowPlanningActionPerformed
        this.splinePanel1.setShowPlanning(this.jCheckBoxShowPlanning.isSelected());
    }//GEN-LAST:event_jCheckBoxShowPlanningActionPerformed

    private void jCheckBoxShowOutlinesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowOutlinesActionPerformed
        this.splinePanel1.setShowOutline(this.jCheckBoxShowOutlines.isSelected());
    }//GEN-LAST:event_jCheckBoxShowOutlinesActionPerformed

    private void jButtonZoomMoreActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonZoomMoreActionPerformed
        this.changeZoom(1.2);
    }//GEN-LAST:event_jButtonZoomMoreActionPerformed

    private void jButtonZoomLessActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonZoomLessActionPerformed
        this.changeZoom(1.0 / 1.2f);
    }//GEN-LAST:event_jButtonZoomLessActionPerformed

    private void jRadioButtonSelectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonSelectActionPerformed
        if (this.jRadioButtonSelect.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.SELECT);
            this.setMoveEnabled(true);
        }
    }//GEN-LAST:event_jRadioButtonSelectActionPerformed

    private void jCheckBoxLabelControlPointsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxLabelControlPointsActionPerformed
        this.splinePanel1.setLabelControlPoints(this.jCheckBoxLabelControlPoints.isSelected());
    }//GEN-LAST:event_jCheckBoxLabelControlPointsActionPerformed

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        this.centerDrawPanelViewPort();
    }//GEN-LAST:event_formComponentResized

    public void Fit() {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension pref_size = this.splinePanel1.getPreferredSize();
        Rectangle2Dd rectB = this.splinePanel1.getBoundingRect();
//        System.out.println("rectB = " + rectB);
        if (null == rectB || rectB.width < 1e-3f || rectB.height < 1e-3f) {
            return;
        }
        int whmaxb = (int) Math.max(rectB.height, rectB.width);
//        System.out.println("whmaxb = " + whmaxb);
        int whmax = Math.max(rect.height, rect.width);
//        System.out.println("whmax = " + whmax);
        int whmax2 = Math.max(whmax, whmaxb);
//        System.out.println("whmax2 = " + whmax2);
        double wscale = ((double) rect.width) / ((double) rectB.width);
//        System.out.println("wscale = " + wscale);
        double hscale = ((double) rect.height) / ((double) rectB.height);
//        System.out.println("hscale = " + hscale);
        double scale = Math.min(wscale, hscale);
        this.splinePanel1.setPreferredSize(new Dimension(rect.width, rect.height));
        //this.splinePanel1.setPreferredSize(new Dimension((int) Math.max(rectB.width, rect.width), (int) Math.max(rect.height, rectB.height)));
        this.splinePanel1.setZoomScale((float) scale);
        this.splinePanel1.setTranslateX(-rectB.x * scale);
        this.splinePanel1.setTranslateY(-rectB.y * scale);
        vp.setViewPosition(new Point(0, 0));
    }

    private void jButtonFitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonFitActionPerformed
        Fit();
    }//GEN-LAST:event_jButtonFitActionPerformed

    public static LinkedList parseList(String s) {
        s = s.trim();
        int left_sq_paren_index = s.indexOf('[');
        if (left_sq_paren_index < 0) {
            return null;
        }
        int right_sq_paren_index = s.lastIndexOf(']');
        if (right_sq_paren_index < left_sq_paren_index) {
            return null;
        }
        s = s.substring(left_sq_paren_index + 1, right_sq_paren_index);
        s = s.trim();
        LinkedList ll = new LinkedList();
        int depth = 0;
        int start = 0;
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (c == '[') {
                if (depth == 0) {
                    start = i;
                }
                depth++;
            } else if (c == ']') {
                depth--;
                if (depth == 0) {
                    try {
                        String clssname = s.substring(0, start);
                        int c_index = clssname.indexOf(',');
                        if (c_index > 0) {
                            clssname = clssname.substring(0, c_index);
                        }
                        c_index = clssname.indexOf('[');
                        if (c_index > 0) {
                            clssname = clssname.substring(0, c_index).trim();
                        }
                        c_index = clssname.indexOf('{');
                        if (c_index > 0) {
                            clssname = clssname.substring(0, c_index).trim();
                        }
                        Class clss = SplineTestJFrame.class.getClassLoader().loadClass(clssname);
                        Method value_of = clss.getMethod("valueOf", String.class);
                        Object o = value_of.invoke(null, s.substring(0, i + 1));
                        if (o != null) {
                            ll.add(o);
                        }
                    } catch (Exception e) {
                        System.err.println("s=" + s);
                        printException(e);
                    }
                    s = s.substring(i + 1);
                    s = s.trim();
                    if (s.startsWith(",")) {
                        s = s.substring(1);
                        s = s.trim();
                    }
                    i = 0;
                }
            }
        }
        return ll;
    }

    private String splinePanelPropertiesToString() {
        try {
            this.splinePanel1.removeImproperBoundaries();
            Class clss = this.splinePanel1.getClass();
            Method ma[] = clss.getDeclaredMethods();
            List<Method> lm = Arrays.asList(ma);
            Collections.sort(lm, new Comparator<Method>() {
                @Override
                public int compare(Method t, Method t1) {
                    return t.getName().compareTo(t1.getName());
                }
            });
            Point p = this.getLocation();
            Dimension sz = this.getSize();
            ma = lm.toArray(new Method[lm.size()]);
            StringBuffer sb = new StringBuffer();
            sb.append("FramePosX=");
            sb.append(p.x);
            sb.append("\n");
            sb.append("FramePosY=");
            sb.append(p.y);
            sb.append("\n");
            sb.append("FrameSizeWidth=");
            sb.append(sz.width);
            sb.append("\n");
            sb.append("FrameSizeHeight=");
            sb.append(sz.height);
            sb.append("\n");
            for (int i = 0; i < ma.length; i++) {
                Method method = ma[i];
                if (method.getName().startsWith("get")) {
                    Class paramtypes[] = method.getParameterTypes();
                    if (null != paramtypes && paramtypes.length != 0) {
                        continue;
                    }
                    sb.append(method.getName().substring(3));
                    sb.append("=");
                    try {
                        sb.append(method.invoke(this.splinePanel1, (Object[]) null));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    sb.append("\n");
                } else if (method.getName().startsWith("is")) {
                    Class paramtypes[] = method.getParameterTypes();
                    if (null != paramtypes && paramtypes.length != 0) {
                        continue;
                    }
                    sb.append(method.getName().substring(2));
                    sb.append("=");
                    try {
                        sb.append(method.invoke(this.splinePanel1, (Object[]) null));
                    } catch (Exception e) {
                        e.printStackTrace();
                    }
                    sb.append("\n");
                }
            }
            return sb.toString();
        } catch (Exception e) {
            printException(e);
        }
        return null;
    }

    private void setSplinePanelPropsFromReader(BufferedReader br) {
        try {
            this.DisconnectFromObsDetection();
            this.DisconnectFromVehicle();
            this.splinePanel1.incrementDelayReplanCount();
            Class clss = this.splinePanel1.getClass();
            Method ma[] = clss.getDeclaredMethods();
            Map<String, Method> methodMap = new HashMap<>();
            for (Method m : ma) {
                methodMap.put(m.getName(), m);
            }
            String line;
            Point p = this.getLocation();
            Dimension sz = this.getSize();
            boolean FrameSizeSet = false;
            boolean FramePosSet = false;
            while ((line = br.readLine()) != null) {
                int eq_index = line.indexOf('=');
                if (eq_index < 0) {
                    continue;
                }
                String var = line.substring(0, eq_index).trim();
                String val = line.substring(eq_index + 1).trim();
                if (var.equalsIgnoreCase("FramePosX")) {
                    int new_x = Integer.valueOf(val);
                    if (new_x != p.x) {
                        p.x = new_x;
                        FramePosSet = true;
                    }
                    continue;
                }
                if (var.equalsIgnoreCase("FramePosY")) {
                    int new_y = Integer.valueOf(val);
                    if (new_y != p.y) {
                        p.y = new_y;
                        FramePosSet = true;
                    }
                    continue;
                }
                if (var.equalsIgnoreCase("FrameSizeWidth")) {
                    int new_width = Integer.valueOf(val);
                    if (new_width != sz.width) {
                        sz.width = new_width;
                        FrameSizeSet = true;
                    }
                    continue;
                }
                if (var.equalsIgnoreCase("FrameSizeHeight")) {
                    int new_height = Integer.valueOf(val);
                    if (new_height != sz.height) {
                        sz.height = new_height;
                        FrameSizeSet = true;
                    }
                    continue;
                }
                String setMethodName = "set" + var;
                Method set_method = methodMap.get(setMethodName);
                if (null != set_method) {
                    Class paramtypes[] = set_method.getParameterTypes();
                    if (null == paramtypes) {
                        continue;
                    }
                    if (paramtypes.length != 1) {
                        continue;
                    }
                    Object o = null;
                    Method value_of = null;
                    try {
                        value_of = paramtypes[0].getDeclaredMethod("valueOf", String.class);
                        o = value_of.invoke((Class[]) null, val);
                    } catch (Exception e) {
                    }
                    if (paramtypes[0] == double.class) {
                        o = Double.valueOf(val);
                    } else if (paramtypes[0] == float.class) {
                        o = Float.valueOf(val);
                    } else if (paramtypes[0] == int.class) {
                        o = Integer.valueOf(val);
                    } else if (paramtypes[0] == boolean.class) {
                        o = Boolean.valueOf(val);
                    } else if (paramtypes[0].isAssignableFrom(LinkedList.class)) {
                        LinkedList ll = parseList(val);
                        o = ll;
                    }
                    if (null != o) {
                        set_method.invoke(this.splinePanel1, o);
                    } else {
                        try {
                            if (val.length() < 1 || val.compareTo("null") == 0) {
                                set_method.invoke(this.splinePanel1, new Object[]{null});
                            } else {
                                set_method.invoke(this.splinePanel1, val);
                            }
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                } else {
                    System.err.println("No method in " + clss + " named " + setMethodName);
                }
            }
            this.splinePanel1.removeImproperBoundaries();
            this.jCheckBoxLabelControlPoints.setSelected(this.splinePanel1.isLabelControlPoints());
            this.jCheckBoxShowOutlines.setSelected(this.splinePanel1.isShowOutline());
            this.jCheckBoxLabelGrid.setSelected(this.splinePanel1.isLabelGrid());
            this.jCheckBoxShowPlanning.setSelected(this.splinePanel1.isShowPlanning());
            this.jCheckBoxShowGrid.setSelected(this.splinePanel1.isShowGrid());
            this.jCheckBoxShowCenterCurve.setSelected(this.splinePanel1.isShowCenterCurve());
            this.jCheckBoxShowSideCurves.setSelected(this.splinePanel1.isShowSideCurves());
            this.jCheckBoxCrab.setSelected(this.splinePanel1.isCrab());
            this.jCheckBoxReverse.setSelected(this.splinePanel1.isReverse());
            this.jCheckBoxExclusiveTracks.setSelected(this.splinePanel1.isExclusivePaths());
            this.jCheckBoxShowPlanOutline.setSelected(this.splinePanel1.isShowPlanOutline());
            this.jCheckBoxMenuItemStaticPlannerList.setSelected(this.splinePanel1.isUse_static_planner_list());
            this.splinePanel1.setCarriers(null);
            this.splinePanel1.StopSimulation();
            this.jCheckBoxSimulation.setSelected(false);
            this.splinePanel1.setCarriers(null);
            this.jCheckBoxMenuItemPlotAllCntlrPts.setSelected(this.splinePanel1.isPlotAllCtrlPtsSent());
            this.jCheckBoxShowControlPath.setSelected(this.splinePanel1.isShowControlPath());
            this.jCheckBoxIgnoreBoundaries.setSelected(this.splinePanel1.isIgnoreBoundaries());
            switch (this.splinePanel1.getGoalSource()) {
                case CONNECTION:
                    this.jRadioButtonMenuItemGoalFromConnection.setSelected(true);
                    break;

                case MANUAL:
                    this.jRadioButtonMenuItemGoalFromWaypoints.setSelected(true);
                    break;

                case WAYPOINTS:
                    this.jRadioButtonMenuItemGoalFromWaypoints.setSelected(true);
                    break;
            }
            switch (this.splinePanel1.getDrawMode()) {
                case SELECT:
                    this.jRadioButtonSelect.setSelected(true);
                    break;

                case START:
                    this.jRadioButtonStart.setSelected(true);
                    break;

                case GOAL:
                    this.jRadioButtonGoal.setSelected(true);
                    break;

                case OBSTACLE:
                    this.jRadioButtonObstacle.setSelected(true);
                    break;

                case BOUNDARY:
                    this.jRadioButtonBoundary.setSelected(true);

                case VERT_BOUNDARY:
                    this.jRadioButtonVertBoundary.setSelected(true);
                    break;

                case HORZ_BOUNDARY:
                    this.jRadioButtonHorzBoundary.setSelected(true);
                    break;

                case PAN:
                    this.jRadioButtonPan.setSelected(true);
                    break;
            }
            this.debugVehicleComm = this.splinePanel1.isDebugVehicleComm();
            this.jCheckBoxMenuItemDebugVehicleComm.setSelected(debugVehicleComm);
            this.debugObsDetComm = this.splinePanel1.isDebugObsDetComm();
            this.jCheckBoxMenuItemDebugObsDetComm.setSelected(debugObsDetComm);
            this.jCheckBoxMenuItemShowBackground.setSelected(this.splinePanel1.isShowBackgroundShapes());
//            if (this.splinePanel1.isConnectedToVehicle()) {
//                this.splinePanel1.setReplanOnAllChanges(false);
//            } else {
//                this.jCheckBoxMenuItemReplanOnAllChanges.setSelected(this.splinePanel1.isReplanOnAllChanges());
//            }
            this.jCheckBoxMenuItemReplanOnAllChanges.setSelected(this.splinePanel1.isReplanOnAllChanges());
            this.DisconnectFromObsDetection();
            this.DisconnectFromVehicle();
            this.jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
            this.jCheckBoxMenuItemConnectToObsDetect.setSelected(false);
            this.jCheckBoxMenuItemConnectedToVehicle.setEnabled(true);
            this.jCheckBoxMenuItemConnectToObsDetect.setEnabled(true);
            this.splinePanel1.setVehicleBack(this.splinePanel1.getVehicleBack());
            this.splinePanel1.setVehicleFront(this.splinePanel1.getVehicleFront());
            this.splinePanel1.setVehicleWidth(this.splinePanel1.getVehicleWidth());
            if (FrameSizeSet) {
                this.setSize(sz);
            }
            if (FramePosSet) {
                this.setLocation(p);
            }
            java.awt.EventQueue.invokeLater(new Runnable() {
                @Override
                public void run() {
                    Fit();
                }
            });
            this.updateAngle();
        } catch (Exception e) {
            printException(e);
        } finally {
            this.splinePanel1.decrementDelayReplanCount();
            this.splinePanel1.replan();
            this.splinePanel1.repaint();
        }
    }

    private void jMenuItemSetPropertyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSetPropertyActionPerformed
        try {
            String new_props = PropertiesJPanel.showDialog(this,
                    splinePanelPropertiesToString());
            if (null == new_props) {
                return;
            }
            BufferedReader br = new BufferedReader(new StringReader(new_props));
            this.setSplinePanelPropsFromReader(br);
        } catch (Exception e) {
            printException(e);
        }
    }//GEN-LAST:event_jMenuItemSetPropertyActionPerformed

    private static void printException(Exception e) {
        System.out.println("");
        System.out.flush();
        System.err.println("");
        System.err.flush();
        if (null != e.getCause()) {
            e.getCause().printStackTrace();
        }
        System.err.println("");
        System.err.flush();
        e.printStackTrace();
        System.err.println("");
        System.err.flush();
    }
    private void jRadioButtonBoundaryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonBoundaryActionPerformed
        if (this.jRadioButtonBoundary.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.BOUNDARY);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonBoundaryActionPerformed
    private Collection<File> RecentFiles;

    /**
     * Get the value of RecentFiles
     *
     * @return the value of RecentFiles
     */
    public Collection<File> getRecentFiles() {
        return RecentFiles;
    }

    public void loadRecentFiles() {
        Collection<File> newRecentFiles = new LinkedHashSet<>();
        try (BufferedReader br = new BufferedReader(new FileReader(recentFileListFile))) {
            String line;
            while (null != (line = br.readLine())) {
                line = line.trim();
                if (line.length() < 1) {
                    continue;
                }
                newRecentFiles.add(new File(line));
            }
            this.setRecentFiles(newRecentFiles);
        } catch (Exception e) {
            printException(e);
        }
    }
    static private final File recentFileListFile
            = new File(System.getProperty("user.home"), ".spline_test_recent_files.txt");

    /**
     * Set the value of RecentFiles
     *
     * @param RecentFiles new value of RecentFiles
     */
    public void setRecentFiles(Collection<File> RecentFiles) {
        this.RecentFiles = RecentFiles;
        this.jMenuRecentFiles.removeAll();
        try (PrintStream ps = new PrintStream(new FileOutputStream(recentFileListFile))) {
            if (null != this.RecentFiles) {
                for (final File f : this.RecentFiles) {
                    JMenuItem mi = new JMenuItem(f.getName());
                    mi.addActionListener(new ActionListener() {
                        @Override
                        public void actionPerformed(ActionEvent ae) {
                            try {
                                BufferedReader br = new BufferedReader(new FileReader(f));
                                setSplinePanelPropsFromReader(br);
                                Fit();
                            } catch (Exception exception) {
                                printException(exception);
                            }
                        }
                    });
                    this.jMenuRecentFiles.add(mi);
                    ps.println(f.getCanonicalPath());
                }
            }
            ps.close();
        } catch (Exception exception) {
            printException(exception);
        }
    }

    private void addRecentFile(File f) {
        Collection<File> newRecentFiles = new LinkedHashSet<>();
        if (null != this.RecentFiles) {
            newRecentFiles.addAll(this.RecentFiles);
        }
        newRecentFiles.add(f);
        this.setRecentFiles(newRecentFiles);
    }

    public void BrowseOpenFile() {
        BufferedReader br = null;
        try {
            JFileChooser chooser = new JFileChooser();
            int chooser_ret = chooser.showOpenDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                br = new BufferedReader(new FileReader(f));
                this.setSplinePanelPropsFromReader(br);
                this.addRecentFile(f);
                Fit();
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
                if (null != br) {
                    br.close();
                }
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    public void BrowseImportDXFBoundaries() {
        try {
            JFileChooser chooser = new JFileChooser();
            chooser.setFileFilter(new FileNameExtensionFilter("Drawing Exchange Format", "dxf"));
            int chooser_ret = chooser.showOpenDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                List<Boundary> boundaries = this.splinePanel1.getBoundaries();
                if (boundaries == null) {
                    boundaries = new LinkedList<>();
                }
                FileInputStream fis = new FileInputStream(f);
                DXFLineShapeExtractor extractor = new DXFLineShapeExtractor(fis);
                String scale_string = JOptionPane.showInputDialog("Scale ?", extractor.getScale());
                try {
                    extractor.setScale(Double.valueOf(scale_string));
                } catch (Exception e) {
                    e.printStackTrace();
                }
                List<Line2Dd> lines = extractor.readLinesFromAllLayers();
                for (Line2Dd l2d : lines) {
                    boundaries.add(new Boundary(l2d.x1, l2d.y1, l2d.x2, l2d.y2));
                }
                try {
                    extractor.close();
                } catch (Exception e) {
                }
                try {
                    fis.close();
                } catch (Exception e) {
                }
                this.splinePanel1.setBoundaries(boundaries);
                Fit();
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    public void BrowseImportDXFBackground() {
        try {
            JFileChooser chooser = new JFileChooser();
            chooser.setFileFilter(new FileNameExtensionFilter("Drawing Exchange Format", "dxf"));
            int chooser_ret = chooser.showOpenDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                List<ShapeWTransform> backgroundShapes = this.splinePanel1.getBackgroundShapes();
                if (backgroundShapes == null) {
                    backgroundShapes = new LinkedList<>();
                }
                FileInputStream fis = new FileInputStream(f);
                DXFLineShapeExtractor extractor = new DXFLineShapeExtractor(fis);
                String scale_string = JOptionPane.showInputDialog("Scale ?", extractor.getScale());
                try {
                    extractor.setScale(Double.valueOf(scale_string));
                } catch (Exception e) {
                    e.printStackTrace();
                }
                List<ShapeWTransform> newShapes = extractor.readShapeWTransformFromAllLayers();
                backgroundShapes.addAll(newShapes);
                try {
                    extractor.close();
                } catch (Exception e) {
                }
                try {
                    fis.close();
                } catch (Exception e) {
                }
                this.splinePanel1.setBackgroundShapes(backgroundShapes);
                Fit();
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    public void BrowseSaveFile() {
        PrintStream ps = null;
        try {
            JFileChooser chooser = new JFileChooser();
            int chooser_ret = chooser.showSaveDialog(this);
            if (chooser_ret == JFileChooser.APPROVE_OPTION) {
                File f = chooser.getSelectedFile();
                String s = this.splinePanelPropertiesToString();
                ps = new PrintStream(new FileOutputStream(f));
                ps.println(s);
                ps.close();
                ps = null;
                this.addRecentFile(f);
            }
        } catch (Exception e) {
            printException(e);
        } finally {
            try {
                if (null != ps) {
                    ps.close();
                }
            } catch (Exception e) {
                printException(e);
            }
        }
    }

    private void jMenuItemFileSaveAsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemFileSaveAsActionPerformed
        this.BrowseSaveFile();
    }//GEN-LAST:event_jMenuItemFileSaveAsActionPerformed

    private void jMenuItemFileOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemFileOpenActionPerformed
        this.BrowseOpenFile();
    }//GEN-LAST:event_jMenuItemFileOpenActionPerformed

    private void jMenuItemDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemDeleteActionPerformed
        this.splinePanel1.DeleteSelection();
    }//GEN-LAST:event_jMenuItemDeleteActionPerformed

    private void jButtonDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDeleteActionPerformed
        this.splinePanel1.DeleteSelection();
    }//GEN-LAST:event_jButtonDeleteActionPerformed
    private final static Point2Dd upMove = new Point2Dd(0f, +1f);

    private void jMenuItemUpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemUpActionPerformed
        try {
            this.splinePanel1.moveSelection(upMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemUpActionPerformed
    private final static Point2Dd downMove = new Point2Dd(0f, -1f);

    private void jMenuItemDownActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemDownActionPerformed
        try {
            this.splinePanel1.moveSelection(downMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemDownActionPerformed
    private final static Point2Dd leftMove = new Point2Dd(-1f, 0f);

    private void jMenuItemLeftActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemLeftActionPerformed
        try {
            this.splinePanel1.moveSelection(leftMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemLeftActionPerformed
    private final static Point2Dd rightMove = new Point2Dd(+1f, 0f);

    private void jMenuItemRightActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemRightActionPerformed
        try {
            this.splinePanel1.moveSelection(rightMove);
        } catch (InterruptedException ex) {
            Logger.getLogger(SplineTestJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jMenuItemRightActionPerformed

    private void jRadioButtonHorzBoundaryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonHorzBoundaryActionPerformed
        if (this.jRadioButtonHorzBoundary.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.HORZ_BOUNDARY);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonHorzBoundaryActionPerformed

    private void jRadioButtonVertBoundaryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonVertBoundaryActionPerformed
        if (this.jRadioButtonVertBoundary.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.VERT_BOUNDARY);
            this.setMoveEnabled(false);
        }
    }//GEN-LAST:event_jRadioButtonVertBoundaryActionPerformed

    private void jCheckBoxShowGridActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowGridActionPerformed
        this.splinePanel1.setShowGrid(this.jCheckBoxShowGrid.isSelected());
    }//GEN-LAST:event_jCheckBoxShowGridActionPerformed

    private void jCheckBoxLabelGridActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxLabelGridActionPerformed
        this.splinePanel1.setLabelGrid(this.jCheckBoxLabelGrid.isSelected());
    }//GEN-LAST:event_jCheckBoxLabelGridActionPerformed

    private void jRadioButtonPanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonPanActionPerformed
        if (this.jRadioButtonPan.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.PAN);
        }
    }//GEN-LAST:event_jRadioButtonPanActionPerformed

    private void formWindowStateChanged(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowStateChanged
        Fit();
    }//GEN-LAST:event_formWindowStateChanged

    private void jCheckBoxSimulationActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxSimulationActionPerformed
        try {
            if (this.jCheckBoxSimulation.isSelected()) {
//            this.jCheckBoxShowOutlines.setSelected(false);
//            this.jCheckBoxShowOutlines.setEnabled(false);
                this.splinePanel1.StartSimulation();
            } else {
                this.splinePanel1.StopSimulation();
//            this.jCheckBoxShowOutlines.setEnabled(true);
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }//GEN-LAST:event_jCheckBoxSimulationActionPerformed

    private void jCheckBoxShowCenterCurveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowCenterCurveActionPerformed
        this.splinePanel1.setShowCenterCurve(this.jCheckBoxShowCenterCurve.isSelected());
    }//GEN-LAST:event_jCheckBoxShowCenterCurveActionPerformed

    private void jCheckBoxShowSideCurvesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowSideCurvesActionPerformed
        this.splinePanel1.setShowSideCurves(this.jCheckBoxShowSideCurves.isSelected());
    }//GEN-LAST:event_jCheckBoxShowSideCurvesActionPerformed

    private void jMenuItemImportDXFBoundariesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemImportDXFBoundariesActionPerformed
        this.BrowseImportDXFBoundaries();
    }//GEN-LAST:event_jMenuItemImportDXFBoundariesActionPerformed

    private void jMenuItemImportDXFBackgroundActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemImportDXFBackgroundActionPerformed
        this.BrowseImportDXFBackground();
    }//GEN-LAST:event_jMenuItemImportDXFBackgroundActionPerformed

    private void jCheckBoxMenuItemConnectedToVehicleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemConnectedToVehicleActionPerformed
        if (this.jCheckBoxMenuItemConnectedToVehicle.isSelected()) {
            ConnectToVehicle();
        } else {
            DisconnectFromVehicle();
        }
    }//GEN-LAST:event_jCheckBoxMenuItemConnectedToVehicleActionPerformed

    private void jCheckBoxCrabActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxCrabActionPerformed
        this.splinePanel1.setCrab(this.jCheckBoxCrab.isSelected());
    }//GEN-LAST:event_jCheckBoxCrabActionPerformed

    private void jCheckBoxMenuItemConnectToObsDetectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemConnectToObsDetectActionPerformed
        if (this.jCheckBoxMenuItemConnectToObsDetect.isSelected()) {
            this.ConnectToObsDetection();
        } else {
            this.DisconnectFromObsDetection();
        }
    }//GEN-LAST:event_jCheckBoxMenuItemConnectToObsDetectActionPerformed

    private void jCheckBoxExclusiveTracksActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxExclusiveTracksActionPerformed
        this.splinePanel1.setExclusivePaths(this.jCheckBoxExclusiveTracks.isSelected());
    }//GEN-LAST:event_jCheckBoxExclusiveTracksActionPerformed

    private void jMenuItemReCheckPathActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemReCheckPathActionPerformed
        try {
            PlannerInput pi = this.splinePanel1.getPlannerInput();
            List<PlannedPath> plannedPaths = this.splinePanel1.getPlannedPaths();
            for (PlannedPath pp : plannedPaths) {
                PlannerPoint last_ppt = null;
                for (PlannerPoint ppt : pp.getControlPoints()) {
                    if (last_ppt != null) {
                        System.out.println("Checking from " + last_ppt);
                        System.out.println("to            " + ppt + " ...");
                        boolean ck = Planner.checkPoint(last_ppt, ppt,
                                pi,
                                true);
                        System.out.println("Planner.checkPoint returned  " + ck);
                        System.out.println("");
                    }
                    last_ppt = ppt;
                }
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }//GEN-LAST:event_jMenuItemReCheckPathActionPerformed

    private void jCheckBoxShowPlanOutlineActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowPlanOutlineActionPerformed
        this.splinePanel1.setShowPlanOutline(this.jCheckBoxShowPlanOutline.isSelected());
    }//GEN-LAST:event_jCheckBoxShowPlanOutlineActionPerformed

    private void jCheckBoxMenuItemDebugVehicleCommActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemDebugVehicleCommActionPerformed
        this.debugVehicleComm = this.jCheckBoxMenuItemDebugVehicleComm.isSelected();
        this.splinePanel1.setDebugVehicleComm(debugVehicleComm);
    }//GEN-LAST:event_jCheckBoxMenuItemDebugVehicleCommActionPerformed
    private boolean debugObsDetComm = false;

    private void jCheckBoxMenuItemDebugObsDetCommActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemDebugObsDetCommActionPerformed
        this.debugObsDetComm = this.jCheckBoxMenuItemDebugObsDetComm.isSelected();
        this.splinePanel1.setDebugObsDetComm(debugObsDetComm);
    }//GEN-LAST:event_jCheckBoxMenuItemDebugObsDetCommActionPerformed

    private void jMenuItemForceReplanningActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemForceReplanningActionPerformed
        this.splinePanel1.forceReplan();
    }//GEN-LAST:event_jMenuItemForceReplanningActionPerformed

    private void jCheckBoxMenuItemShowBackgroundActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemShowBackgroundActionPerformed
        this.splinePanel1.setShowBackgroundShapes(this.jCheckBoxMenuItemShowBackground.isSelected());
        this.splinePanel1.repaint();
    }//GEN-LAST:event_jCheckBoxMenuItemShowBackgroundActionPerformed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
        this.splinePanel1.setBackgroundShapes(null);
        this.splinePanel1.repaint();
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jCheckBoxMenuItemReplanOnAllChangesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemReplanOnAllChangesActionPerformed
        this.splinePanel1.setReplanOnAllChanges(this.jCheckBoxMenuItemReplanOnAllChanges.isSelected());
    }//GEN-LAST:event_jCheckBoxMenuItemReplanOnAllChangesActionPerformed

    private void jCheckBoxReverseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxReverseActionPerformed
        this.splinePanel1.setReverse(this.jCheckBoxReverse.isSelected());
    }//GEN-LAST:event_jCheckBoxReverseActionPerformed

    private void jMenuItemSwapGoalStartActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSwapGoalStartActionPerformed
        this.splinePanel1.swapGoalStart();
    }//GEN-LAST:event_jMenuItemSwapGoalStartActionPerformed

    public void plotSplines() {
        try {
            for (PlannedPath path : this.splinePanel1.getPlannedPaths()) {
                File f = File.createTempFile("spline_", ".csv");
                PrintStream ps = new PrintStream(new FileOutputStream(f));
                ps.println("x,y");
                for (Point2Dd pt : path.getCurvePoints()) {
                    String s = "" + pt.x + "," + pt.y;
                    ps.println(s);
                    System.out.println(s);
                }
                ps.close();
                String args[] = {"--plotVsLineNumber=true", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                    f.getCanonicalPath()};
                diagapplet.plotter.plotterJFrame.main(args);
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    public void plotSplineCurveRadius() {
        try {
            for (PlannedPath path : this.splinePanel1.getPlannedPaths()) {
                File f = File.createTempFile("spline_curve_radius_", ".csv");
                PrintStream ps = new PrintStream(new FileOutputStream(f));
                ps.println("dist,dot,radius");
                Point2Dd last_pt = null;
                Point2Dd last_diffu = null;
                for (Point2Dd pt : path.getCurvePoints()) {
                    double max_radius = 10.0 * this.splinePanel1.getMinTurnRadius();
                    if (max_radius < 100.0) {
                        max_radius = 100.0;
                    }
                    if (null != last_pt) {
                        Point2Dd diff = pt.diff(last_pt);
                        Point2Dd diffu = diff.unit();
                        double dist = diff.mag();
                        if (null != last_diffu) {
                            double dot = diffu.dot(last_diffu);
                            double radius = max_radius;
                            if (Math.abs(dot - 1.0) > Double.MIN_NORMAL) {
                                radius = dist / Math.sqrt(2 * (1 - dot));
                            }
                            if (radius > max_radius) {
                                radius = max_radius;
                            }
                            ps.println(dist + "," + dot + "," + radius);
                        }
                        last_diffu = diffu;
                    }
                    last_pt = pt;
                }
                ps.close();
                String args[] = {"--plotVsLineNumber=true", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                    f.getCanonicalPath()};
                diagapplet.plotter.plotterJFrame.main(args);
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    public void plotSplinesWithControlPoints() {
        try {
            for (PlannedPath path : this.splinePanel1.getPlannedPaths()) {
                File f = File.createTempFile("spline_", ".csv");
                PrintStream ps = new PrintStream(new FileOutputStream(f));
                ps.println("x,y");
                for (Point2Dd pt : path.getCurvePoints()) {
                    String s = "" + pt.x + "," + pt.y;
                    ps.println(s);
                    System.out.println(s);
                }
                ps.close();
                File f2 = File.createTempFile("ctnrl_pts_", ".csv");
                PrintStream ps2 = new PrintStream(new FileOutputStream(f2));
                ps2.println("x,y");
                for (Point2Dd pt : path.getExtendedControlPoints()) {
                    String s = "" + pt.x + "," + pt.y;
                    ps2.println(s);
                    System.out.println(s);
                }
                ps2.close();
                String args[] = {"--plotVsLineNumber=true", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                    f.getCanonicalPath(), f2.getCanonicalPath()};
                diagapplet.plotter.plotterJFrame.main(args);
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    public void plotLastCntrlPtsSent() {
        try {
            if (this.last_cntrl_pts_sent_ba == null) {
                System.err.println("jMenuItemPlotLastCntrlPtsSentActionPerformed: this.last_cntrl_pts_sent_ba == null");
                return;
            }
            ByteBuffer bb = ByteBuffer.wrap(this.last_cntrl_pts_sent_ba);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            File f = File.createTempFile("cntrl_pts_" + this.sendControlPointsCount + "_" + this.lastsegid, ".csv");
            PrintStream ps = new PrintStream(new FileOutputStream(f));
            ps.println("x,y");
            for (int i = 12; i < this.last_cntrl_pts_sent_ba.length - 7; i += 8) {
                int ix = bb.getInt(i);
                int iy = bb.getInt(i + 4);
                String s = "" + ix + "," + iy;
                ps.println(s);
                System.out.println(s);
            }
            ps.close();
            String args[] = {"--plotVsLineNumber=true", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                f.getCanonicalPath()};
            diagapplet.plotter.plotterJFrame.main(args);
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }
    private void jMenuItemPlotLastCntrlPtsSentActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemPlotLastCntrlPtsSentActionPerformed
        this.plotLastCntrlPtsSent();
    }//GEN-LAST:event_jMenuItemPlotLastCntrlPtsSentActionPerformed

    private void jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed
        this.splinePanel1.setPlotAllCtrlPtsSent(this.jCheckBoxMenuItemPlotAllCntlrPts.isSelected());
    }//GEN-LAST:event_jCheckBoxMenuItemPlotAllCntlrPtsActionPerformed

    private void jCheckBoxShowControlPathActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxShowControlPathActionPerformed
        this.splinePanel1.setShowControlPath(this.jCheckBoxShowControlPath.isSelected());
    }//GEN-LAST:event_jCheckBoxShowControlPathActionPerformed

    private void jMenuItemPlotSplinesWithControlPointsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemPlotSplinesWithControlPointsActionPerformed
        this.plotSplines();
    }//GEN-LAST:event_jMenuItemPlotSplinesWithControlPointsActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        this.plotSplinesWithControlPoints();
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jMenuItemPlotCurveRadiusActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemPlotCurveRadiusActionPerformed
        this.plotSplineCurveRadius();
    }//GEN-LAST:event_jMenuItemPlotCurveRadiusActionPerformed

    private void jButtonModifyAngleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonModifyAngleActionPerformed
        try {
            String res = JOptionPane.showInputDialog(this, "Angle for new Goal/Start positions?",
                    this.splinePanel1.getStartingAngle());
            if (null != res) {
                this.splinePanel1.setStartingAngle(Double.valueOf(res.trim()));
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
        this.updateAngle();
    }//GEN-LAST:event_jButtonModifyAngleActionPerformed

    private void jRadioButtonWaypointActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonWaypointActionPerformed
        if (this.jRadioButtonWaypoint.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.WAYPOINT);
            this.setMoveEnabled(false);
        }
        this.updateAngle();
    }//GEN-LAST:event_jRadioButtonWaypointActionPerformed

    private void jRadioButtonMenuItemGoalFromConnectionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonMenuItemGoalFromConnectionActionPerformed
        if (this.jRadioButtonMenuItemGoalFromConnection.isSelected()) {
            this.splinePanel1.setGoalSource(GoalSourceEnum.CONNECTION);
        }
    }//GEN-LAST:event_jRadioButtonMenuItemGoalFromConnectionActionPerformed

    private void jRadioButtonMenuItemManualGoalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonMenuItemManualGoalActionPerformed
        if (this.jRadioButtonMenuItemManualGoal.isSelected()) {
            this.splinePanel1.setGoalSource(GoalSourceEnum.MANUAL);
        }
    }//GEN-LAST:event_jRadioButtonMenuItemManualGoalActionPerformed

    private void jRadioButtonMenuItemGoalFromWaypointsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonMenuItemGoalFromWaypointsActionPerformed
        if (this.jRadioButtonMenuItemGoalFromWaypoints.isSelected()) {
            this.splinePanel1.setGoalSource(GoalSourceEnum.WAYPOINTS);
        }
    }//GEN-LAST:event_jRadioButtonMenuItemGoalFromWaypointsActionPerformed

    private void jCheckBoxIgnoreBoundariesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxIgnoreBoundariesActionPerformed
        this.splinePanel1.setIgnoreBoundaries(this.jCheckBoxIgnoreBoundaries.isSelected());
    }//GEN-LAST:event_jCheckBoxIgnoreBoundariesActionPerformed
    BlockingQueue<Integer> manualGoalBlockingQueue = new SynchronousQueue<>();
    int goal_count = 0;
    private void jButtonSendManualGoalActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonSendManualGoalActionPerformed
        goal_count++;
        try {
            if (manualGoalBlockingQueue.isEmpty()) {
                manualGoalBlockingQueue.add(goal_count);
            }
        } catch (Exception e) {
        }
    }//GEN-LAST:event_jButtonSendManualGoalActionPerformed

    private void jButtonUpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonUpActionPerformed
        this.splinePanel1.setStartingAngle(90.0);
        this.updateAngle();
    }//GEN-LAST:event_jButtonUpActionPerformed

    private void jButtonDownActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonDownActionPerformed
        this.splinePanel1.setStartingAngle(270.0);
        this.updateAngle();
    }//GEN-LAST:event_jButtonDownActionPerformed

    private void jButtonLeftActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonLeftActionPerformed
        this.splinePanel1.setStartingAngle(180.0);
        this.updateAngle();
    }//GEN-LAST:event_jButtonLeftActionPerformed

    private void jButtonRightActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRightActionPerformed
        this.splinePanel1.setStartingAngle(0.0);
        this.updateAngle();
    }//GEN-LAST:event_jButtonRightActionPerformed

    private Vector<String> planParamVector = null;

    public Vector<String> getPlanParamVector() {
        if (null != planParamVector) {
            return planParamVector;
        }
        planParamVector = new Vector<>();
        Class cls = PlannerInput.class;
        Field fa[] = cls.getFields();
        PlannerInput pi = this.splinePanel1.getPlannerInput();
        for (Field f : fa) {
            Class type = f.getType();
            Object val = "";
            try {
                val = "=" + f.get(pi).toString();
            } catch (Exception e) {

            }
            if (type.isAssignableFrom(Integer.class)) {
                planParamVector.add(f.getName() + val);
                continue;
            }
            if (type.isAssignableFrom(int.class)) {
                planParamVector.add(f.getName() + val);
                continue;
            }
            if (type.isAssignableFrom(Float.class)) {
                planParamVector.add(f.getName() + val);
                continue;
            }
            if (type.isAssignableFrom(float.class)) {
                planParamVector.add(f.getName() + val);
                continue;
            }
            if (type.isAssignableFrom(Double.class)) {
                planParamVector.add(f.getName() + val);
                continue;
            }
            if (type.isAssignableFrom(double.class)) {
                planParamVector.add(f.getName() + val);
                continue;
            }
        }
        return planParamVector;
    }

    public ParamRange queryPlanParamRange() {
        return ParamRangeJPanel.queryParamRange(getPlanParamVector(), this);
    }

    private ProgressMonitor testProgressMonitor = null;

    class TestTask extends SwingWorker<Void, Void> {

        ProgressMonitor testProgressMonitor = null;
        ParamRange pr = null;
        File f = null;
        boolean orig_replan_on_all_changes = false;

        @Override
        public Void doInBackground() {
            setProgress(0);

            PlannerInput pi = splinePanel1.getPlannerInput();
            List<CarrierState> startPoints = splinePanel1.getStartPoints();
            List<CarrierState> goalPoints = splinePanel1.getGoalPoints();
            List<CarrierState> wayPoints = splinePanel1.getWaypoints();
            try {
                f = File.createTempFile("planning_test_" + pr.paramName, ".csv");
                PrintStream ps = new PrintStream(new FileOutputStream(f));
                ps.println(pr.paramName + ",npoints,ltime,ptime,ttime,points_checked,lsize");
                for (int i = 0; i < pr.increments; i++) {
                    double v = pr.min + (pr.max - pr.min) * i / pr.increments;
                    pi.getClass().getField(pr.paramName).setDouble(pi, v);
                    long t1 = System.currentTimeMillis();
                    pi.start = startPoints.get(0);
                    pi.goal = goalPoints.get(0);
                    if (null != testProgressMonitor && testProgressMonitor.isCanceled()) {
                        return null;
                    }
                    List<PlannerPoint> ll = Planner.createPlannerList(pi, startPoints, goalPoints, wayPoints);
                    long t2 = System.currentTimeMillis();
                    if (null != testProgressMonitor && testProgressMonitor.isCanceled()) {
                        return null;
                    }
                    List<PlannerPoint> newControlPoints = Planner.planWithPlannerList(pi, ll);
                    long t3 = System.currentTimeMillis();
                    long ltime = t2 - t1;
                    long ptime = t3 - t2;
                    long ttime = t3 - t1;
                    int npoints = (newControlPoints == null) ? 0 : newControlPoints.size();
                    int lsize = ll.size();
                    ps.println(v + "," + npoints + "," + ltime + "," + ptime + "," + ttime + "," + Planner.points_checked + "," + lsize);
                    setProgress(i);
                    if (null != testProgressMonitor && testProgressMonitor.isCanceled()) {
                        return null;
                    }
                }
                ps.close();

            } catch (Exception exception) {
                exception.printStackTrace();
            }

            return null;
        }

        @Override
        public void done() {
            try {
                jCheckBoxMenuItemReplanOnAllChanges.setSelected(orig_replan_on_all_changes);
                splinePanel1.setReplanOnAllChanges(orig_replan_on_all_changes);
                testProgressMonitor.close();
                splinePanel1.running_param_test = false;
                String args[] = {"--plotVsLineNumber=false", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                    f.getCanonicalPath()};
                diagapplet.plotter.plotterJFrame.main(args);

            } catch (Exception exception) {
                exception.printStackTrace();
            }
        }
    }

    private void jMenuItemTestPlanningParamActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemTestPlanningParamActionPerformed
        ParamRange pr = queryPlanParamRange();
        if (null == pr) {
            return;
        }
        System.out.println("Testing " + pr.paramName + " from " + pr.min + " to " + pr.max + " using " + pr.increments + " increments");
        boolean orig_replan_on_changes = this.jCheckBoxMenuItemReplanOnAllChanges.isSelected();
        this.jCheckBoxMenuItemReplanOnAllChanges.setSelected(false);
        this.splinePanel1.setReplanOnAllChanges(false);
        this.splinePanel1.running_param_test = true;
        this.splinePanel1.interruptPlanning();

        testProgressMonitor
                = new ProgressMonitor(this,
                        "Testing " + pr.paramName + " from " + pr.min + " to " + pr.max + " with " + pr.increments + " increments.",
                        "", 0, pr.increments);
        TestTask tt = new TestTask();
        tt.testProgressMonitor = testProgressMonitor;
        tt.pr = pr;
        tt.orig_replan_on_all_changes = orig_replan_on_changes;
        tt.addPropertyChangeListener(new PropertyChangeListener() {

            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                try {
                    testProgressMonitor.setProgress((Integer) evt.getNewValue());
                } catch (Exception e) {
                }
            }
        });
        tt.execute();
    }//GEN-LAST:event_jMenuItemTestPlanningParamActionPerformed

    private void jCheckBoxMenuItemStaticPlannerListActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemStaticPlannerListActionPerformed
        this.splinePanel1.setUse_static_planner_list(this.jCheckBoxMenuItemStaticPlannerList.isSelected());
    }//GEN-LAST:event_jCheckBoxMenuItemStaticPlannerListActionPerformed

    private void jRadioButtonDrawPlanningRectActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRadioButtonDrawPlanningRectActionPerformed
        if (this.jRadioButtonDrawPlanningRect.isSelected()) {
            this.splinePanel1.setDrawMode(SplineDrawMode.DRAW_PLANNING_RECT);
        }
    }//GEN-LAST:event_jRadioButtonDrawPlanningRectActionPerformed

    private void jCheckBoxMenuItemRecordPlannerStatsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemRecordPlannerStatsActionPerformed
        Planner.record_stats = this.jCheckBoxMenuItemRecordPlannerStats.isSelected();
    }//GEN-LAST:event_jCheckBoxMenuItemRecordPlannerStatsActionPerformed

    private void jMenuItemPlotRecordedPlannerStatsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemPlotRecordedPlannerStatsActionPerformed

        try {
            File f = Planner.recordStatsFile;
            if (null != f) {
                String args[] = {"--plotVsLineNumber=true", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                    f.getCanonicalPath()};
                diagapplet.plotter.plotterJFrame.main(args);
            }
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }//GEN-LAST:event_jMenuItemPlotRecordedPlannerStatsActionPerformed

    class TestAllPositionsTask extends SwingWorker<Void, Void> {

        final ProgressMonitor testProgressMonitor;
        final boolean orig_replan_on_all_changes;
        final boolean orig_planner_recordStats;
        final Rectangle2Dd rect;
        final int num_tests;
        final int seed;
        final double plannerPointSize;
        final double width;
        final double front;
        final double back;

        TestAllPositionsTask(ProgressMonitor _testProgressMonitor,
                boolean _orig_replan_on_all_changes,
                boolean _orig_planner_recordStats,
                Rectangle2Dd _rect,
                int _num_tests,
                int _seed,
                double _plannerPointSize,
                double _width,
                double _front,
                double _back) {
            super();
            this.testProgressMonitor = _testProgressMonitor;
            this.orig_replan_on_all_changes = _orig_replan_on_all_changes;
            this.orig_planner_recordStats = _orig_planner_recordStats;
            this.rect = _rect;
            this.num_tests = _num_tests;
            this.seed = _seed;
            this.plannerPointSize = _plannerPointSize;
            this.width = _width;
            this.front = _front;
            this.back = _back;
        }

        @Override
        public Void doInBackground() {
            setProgress(0);
            PlannerInput pi = splinePanel1.getPlannerInput();
            List<CarrierState> startPoints = splinePanel1.getStartPoints();
            List<CarrierState> goalPoints = splinePanel1.getGoalPoints();
            List<CarrierState> wayPoints = splinePanel1.getWaypoints();
            try {
                Planner.closeRecordStatsFile();
                Random r = new Random(seed);
                for (int i = 0; i < num_tests; i++) {
                    Planner.record_stats = true;
                    pi.start = null;
                    while (pi.start == null) {
                        pi.start = new CarrierState(r.nextDouble() * rect.width + rect.x,
                                r.nextDouble() * rect.height + rect.y,
                                new AngleD(r.nextDouble() * Math.PI * 2),
                                CarrierStateTypeEnum.START,
                                plannerPointSize,
                                width,
                                front,
                                back);
                        if (pi.start.checkBoundaries(splinePanel1.getBoundaries())) {
                            pi.start = null;
                            continue;
                        }
                        if (pi.start.checkObstacles(splinePanel1.getObstacles())) {
                            pi.start = null;
                        }
                    }
                    pi.goal = null;
                    while (pi.goal == null) {
                        pi.goal = new CarrierState(r.nextDouble() * rect.width + rect.x,
                                r.nextDouble() * rect.height + rect.y,
                                new AngleD(r.nextDouble() * Math.PI * 2),
                                CarrierStateTypeEnum.GOAL,
                                plannerPointSize,
                                width,
                                front,
                                back);
                        if (pi.goal.checkBoundaries(splinePanel1.getBoundaries())) {
                            pi.goal = null;
                            continue;
                        }
                        if (pi.goal.checkObstacles(splinePanel1.getObstacles())) {
                            pi.goal = null;
                        }
                    }
                    pi.start.setGoal(pi.goal);
                    if (null != testProgressMonitor && testProgressMonitor.isCanceled()) {
                        return null;
                    }
                    List<PlannerPoint> ll = Planner.createPlannerList(pi, startPoints, goalPoints, wayPoints);
                    long t2 = System.currentTimeMillis();
                    if (null != testProgressMonitor && testProgressMonitor.isCanceled()) {
                        return null;
                    }
                    List<PlannerPoint> newControlPoints = Planner.planWithPlannerList(pi, ll);
                    final List<PlannerPoint> fll = ll;
                    final List<PlannerPoint> fcp = newControlPoints;
                    final CarrierState fstart = pi.start;
                    final CarrierState fgoal = pi.goal;
                    java.awt.EventQueue.invokeLater(new Runnable() {

                        @Override
                        public void run() {
                            splinePanel1.updatePlannerInfo(fstart, fgoal, fll, fcp);
                            splinePanel1.repaint();
                        }
                    });

                    setProgress(i);
                    if (null != testProgressMonitor && testProgressMonitor.isCanceled()) {
                        return null;
                    }
                }

            } catch (Exception exception) {
                exception.printStackTrace();
            }

            return null;
        }

        @Override
        public void done() {
            try {
                jCheckBoxMenuItemReplanOnAllChanges.setSelected(orig_replan_on_all_changes);
                splinePanel1.setReplanOnAllChanges(orig_replan_on_all_changes);
                Planner.record_stats = this.orig_planner_recordStats;
                jCheckBoxMenuItemRecordPlannerStats.setSelected(Planner.record_stats);
                testProgressMonitor.close();
                splinePanel1.running_param_test = false;
                String args[] = {"--plotVsLineNumber=false", "--FieldSeparator=,", "--cmdLineMode", "--disposeOnClose",
                    Planner.recordStatsFile.getCanonicalPath()};
                diagapplet.plotter.plotterJFrame.main(args);

            } catch (Exception exception) {
                exception.printStackTrace();
            }
        }
    }

    private void jMenuItemTestAllPositonsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemTestAllPositonsActionPerformed
        boolean orig_replan_on_changes = this.jCheckBoxMenuItemReplanOnAllChanges.isSelected();
        boolean orig_planner_recordStats = Planner.record_stats;
        Planner.record_stats = true;
        jCheckBoxMenuItemRecordPlannerStats.setSelected(true);

        this.jCheckBoxMenuItemReplanOnAllChanges.setSelected(false);
        this.splinePanel1.setReplanOnAllChanges(false);
        this.splinePanel1.running_param_test = true;
        this.splinePanel1.interruptPlanning();
        Rectangle2Dd rect = this.splinePanel1.getPlanningAreaRect();
        if (null == rect) {
            rect = this.splinePanel1.getBoundingRect();
        }
        testProgressMonitor
                = new ProgressMonitor(this,
                        "Testing All Positions",
                        "", 0, 1000);
        TestAllPositionsTask tt = new TestAllPositionsTask(testProgressMonitor,
                orig_replan_on_changes,
                orig_planner_recordStats,
                rect,
                1000,
                1111,
                this.splinePanel1.getPlannerPointDisplaySize(),
                this.splinePanel1.getVehicleWidth(),
                this.splinePanel1.getVehicleFront(),
                this.splinePanel1.getVehicleBack());

        tt.addPropertyChangeListener(new PropertyChangeListener() {

            @Override
            public void propertyChange(PropertyChangeEvent evt) {
                try {
                    testProgressMonitor.setProgress((Integer) evt.getNewValue());
                } catch (Exception e) {
                }
            }
        });
        tt.execute();
    }//GEN-LAST:event_jMenuItemTestAllPositonsActionPerformed

    public void updateAngle() {
        try {
            this.jLabelAngle.setText(String.format(" Angle(in degrees): %.1f ", this.splinePanel1.getStartingAngle()));
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    Thread monitorVehicleThread = null;
    Socket socket_to_vehicle = null;
    private byte obsDetectBa[] = null;
    private Thread obsDetectThread = null;
    private DatagramPacket obsDetectPacket = null;
    private DatagramSocket obsDetectSocket = null;
    private final SocketAddress obsAddress = new InetSocketAddress(5555);
    List<List<Obstacle>> obsHistory = null;
    Map<List<Obstacle>, Double> obsTimeStamps = null;
    List<Obstacle> lastObsList = null;

    public boolean MatchObsList(List<Obstacle> newObsList) {
        if (lastObsList == null) {
            return newObsList == null || newObsList.size() == 0;
        }
        if (lastObsList.size() != newObsList.size()) {
            return false;
        }
        for (int i = 0; i < lastObsList.size(); i++) {
            double min_diff = Double.POSITIVE_INFINITY;
            Obstacle obsi = lastObsList.get(i);
            double min_dist_radius = Double.POSITIVE_INFINITY;
            for (int j = 0; j < newObsList.size(); j++) {
                Obstacle obsj = newObsList.get(j);
                double diff = obsi.distance(obsj);
                if (diff < min_diff) {
                    min_diff = diff;
                    min_dist_radius = obsj.radius;
                }
            }
            if (min_diff > 20.0) {
                return false;
            }
            if (Math.abs(obsi.radius - min_dist_radius) > 20.0) {
                return false;
            }
        }
        return true;
    }

    public void ReadFromObsDetect() {
        try {
            debugObsDetComm = this.splinePanel1.isDebugObsDetComm();
            obsHistory = new LinkedList<>();
            obsTimeStamps = new HashMap<>();
            int readobsdet_count = 0;
            while (!Thread.currentThread().isInterrupted()) {
                readobsdet_count++;
                if (debugObsDetComm) {
                    System.out.println("readobsdet_count = " + readobsdet_count);
                }
                if (null == obsDetectSocket || null == obsDetectPacket) {
                    return;
                }
                obsDetectSocket.receive(obsDetectPacket);
                ByteBuffer bb = ByteBuffer.wrap(obsDetectPacket.getData());
                if (debugObsDetComm) {
                    System.out.println("ReadFromObsDetectRead:");
                    printByteArray(bb.array());
                }
                double timeStamp = bb.getDouble();
                if (debugObsDetComm) {
                    System.out.println("timeStamp = " + timeStamp);
                }
                int num_obs = bb.getInt();
                if (debugObsDetComm) {
                    System.out.println("num_obs = " + num_obs);
                }
                final List<Obstacle> newObsList = new LinkedList<>();
                List<Obstacle> prevObstacles = null;
                while (obsHistory.size() > 0) {
                    prevObstacles = obsHistory.get(0);
                    try {
                        Double prev_timestamp = obsTimeStamps.get(prevObstacles);
                        if (prev_timestamp != null && timeStamp - prev_timestamp < 5.0) {
                            break;
                        }
                    } catch (Exception e) {
                        e.printStackTrace();
                        break;
                    }
                    obsHistory.remove(0);
                    obsTimeStamps.remove(prevObstacles);
                }
                for (int i = 0; i < num_obs; i++) {
                    float x = bb.getFloat();
                    float y = bb.getFloat();
                    float vx = bb.getFloat();
                    float vy = bb.getFloat();
                    float radius = bb.getFloat();
                    if (radius < Float.MIN_NORMAL) {
                        continue;
                    }
                    Obstacle new_obs
                            = new Obstacle(x * 100.0, y * 100.0, radius * 100.0);
                    List<CarrierState> spl = this.splinePanel1.getStartPoints();
                    boolean skip_obs = false;
                    for (CarrierState sp : spl) {
                        if (sp.checkObstacleEx(new_obs, 50.)) {
                            skip_obs = true;
                            break;
                        }
                    }
                    if (skip_obs) {
                        continue;
                    }
                    newObsList.add(new_obs);
                }

                final List<Obstacle> obsListCopy = new LinkedList<>();
                obsListCopy.addAll(newObsList);
                obsHistory.add(obsListCopy);
                java.awt.EventQueue.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        splinePanel1.setTempObstacles(obsListCopy);
                    }
                });
                obsTimeStamps.put(obsListCopy, timeStamp);
                if (null != prevObstacles) {
                    for (int i = 0; i < newObsList.size(); i++) {
                        Obstacle obsi = newObsList.get(i);
                        boolean match_found = false;
                        for (int j = 0; j < prevObstacles.size(); j++) {
                            Obstacle obsj = prevObstacles.get(j);
                            if (obsj.distance(obsi) < 20.0
                                    && Math.abs(obsj.radius - obsi.radius) < 20.0) {
                                match_found = true;
                                break;
                            }
                        }
                        if (!match_found) {
                            newObsList.remove(i);
                            i--;
                        }
                    }
                    obsDetectSocket.close();
                    if (!checking_vehicle && !MatchObsList(newObsList)) {
                        lastObsList = newObsList;
                        java.awt.EventQueue.invokeAndWait(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.setObstacles(newObsList);
                                splinePanel1.replan();
                            }
                        });
                    }
                    obsDetectSocket = new DatagramSocket(5555);
                    this.obsDetectSocket.setReuseAddress(true);
                    obsDetectBa = new byte[1024];
                    obsDetectPacket = new DatagramPacket(obsDetectBa, obsDetectBa.length);
                }

//                this.obsDetectSocket.close();
//                this.obsDetectSocket = new DatagramSocket(5555);
//                this.obsDetectSocket.setReuseAddress(true);
                Thread.sleep(300);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void ConnectToObsDetection() {
        try {
            this.lastObsList = null;
            this.DisconnectFromObsDetectionInner();
            obsDetectSocket = new DatagramSocket(5555);
            if (this.debugObsDetComm) {
                System.out.println("Starting obsDetect thread to listen for UDP packets on port :" + obsDetectSocket.getLocalPort());
            }
            this.obsDetectSocket.setReuseAddress(true);
            obsDetectBa = new byte[1024];
            obsDetectPacket = new DatagramPacket(obsDetectBa, obsDetectBa.length);
            obsDetectThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    ReadFromObsDetect();
                }
            }, "obsDetectThread");
            obsDetectThread.start();
            if (!this.jCheckBoxMenuItemConnectToObsDetect.isSelected()) {
                this.jCheckBoxMenuItemConnectToObsDetect.setSelected(true);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void DisconnectFromObsDetectionInner() {
        try {
            this.lastObsList = null;
            if (null != this.obsDetectThread) {
                this.obsDetectThread.interrupt();
                if (null != this.obsDetectSocket) {
                    this.obsDetectSocket.close();
                    this.obsDetectSocket = null;
                }
                this.obsDetectThread.join();
                this.obsDetectThread = null;
            }
            if (null != this.obsDetectSocket) {
                this.obsDetectSocket.close();
                this.obsDetectSocket = null;
            }
            this.obsDetectPacket = null;
            this.obsDetectBa = null;
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void DisconnectFromObsDetection() {
        this.DisconnectFromObsDetectionInner();
        if (this.jCheckBoxMenuItemConnectToObsDetect.isSelected()) {
            this.jCheckBoxMenuItemConnectToObsDetect.setSelected(false);
        }
        this.lastObsList = null;
    }

    public static void printByteArray(byte ba[]) {
        //System.out.println("("+ba.length +" bytes)");
        for (int i = 0; i < ba.length; i++) {
            byte b = ba[i];
            System.out.printf("%02X", b);
            if ((i + 1) % 4 == 0) {
                System.out.print(" ");
            }
        }
    }
    private int sendControlPointsCount = 0;

    public void ShowMessageBox(final String s) {
        String ss = s;
        if (ss.length() > 70) {
            ss = ss.substring(0, 69);
        }
        JOptionPane.showMessageDialog(this, ss);
    }

    public void ShowError(final String s) {
        try {
            System.out.println("");
            System.out.flush();
            System.err.println(s);
            java.awt.EventQueue.invokeAndWait(new Runnable() {
                @Override
                public void run() {
                    ShowMessageBox(s);
                }
            });
        } catch (InterruptedException interruptedException) {
        } catch (InvocationTargetException invocationTargetException) {
        }
    }
    byte last_cntrl_pts_sent_ba[] = null;
    Point2Dd lastGoal;

    public boolean sendControlPoints(Socket socket,
            final CarrierState csStart,
            final CarrierState csEnd,
            final List<PlannerPoint> cntrlPts,
            final List<PlannerPoint> planner_list,
            boolean crab,
            int segsx, int segsy, short segsangle,
            int segex, int segey, short segeangle,
            short segi,
            short speed_mm_s) {
        ByteBuffer bb = null;
        try {
            OutputStream os = socket.getOutputStream();
            sendControlPointsCount++;
            if (debugVehicleComm) {
                System.out.println("sendControlPointsCount = " + sendControlPointsCount);
            }
            if (null == cntrlPts) {
                System.out.println("sendControlPoints : cntrlPts == null");
                return false;
            }
            int num_pts = cntrlPts.size();
            if (num_pts < 4) {
                ShowError("sendControlPoints : num_pts too few: " + num_pts);
                return false;
            }
            if (num_pts > 16) {
                ShowError("sendControlPoints : num_pts too many: " + num_pts);
                return false;
            }
            if (cntrlPts.get(0).distance(cntrlPts.get(num_pts - 1)) < 10) {
                return false;
            }
            int bbsz = 28 + num_pts * 8;
            double start_seg = this.splinePanel1.getSegStartLength() * 10.0;

            //start_seg = 10.0;
            int nsz = cntrlPts.size();
            double end_seg = start_seg;

            //end_seg = 10.0;
            bb = ByteBuffer.allocate(bbsz);
//            System.out.println("bb = " + bb);
//            System.out.println("bb.capacity() = " + bb.capacity());
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort((short) 0x64);
            bb.putShort((short) bbsz);
            if (this.splinePanel1.isCrab()) {
                bb.putShort((short) 2); // send crab spline
                segeangle = segsangle;
            } else {
                bb.putShort((short) 1); // send normal spline
            }
            bb.putShort((short) speed_mm_s); // 200 mm/s

            bb.putShort(segsangle);
            bb.putShort(segeangle);
//                        bb.putShort((short) 0);
//                        bb.putShort((short) 0);
            double startAngle = Math.toRadians(segsangle / 100.0);
            if (speed_mm_s < 0) {
                startAngle += Math.PI;
            }
            double ss = Math.sin(startAngle);
            double cs = Math.cos(startAngle);
            Point2Dd diffu = cntrlPts.get(cntrlPts.size() - 1).diff(cntrlPts.get(0)).unit();
            if (crab) {
                ss = diffu.y;
                cs = diffu.x;
            }
            if (false && (this.splinePanel1.getGoalSource() == GoalSourceEnum.MANUAL)
                    && null != this.last_three_pts_sent
                    && Math.abs(segsx - this.last_three_pts_sent[2]) < 20
                    && Math.abs(segsy - this.last_three_pts_sent[3]) < 20) {
                for (int i = 0; i < 6; i++) {
                    bb.putInt(this.last_three_pts_sent[i]);
                }
            } else {
                bb.putInt(segsx - (int) (cs * start_seg));
                bb.putInt(segsy - (int) (ss * start_seg));
                bb.putInt(segsx);
                bb.putInt(segsy);
                bb.putInt(segsx + (int) (cs * start_seg));
                bb.putInt(segsy + (int) (ss * start_seg));
            }
            for (int i = 2; i < num_pts - 2; i++) {
                Point2Dd pt = cntrlPts.get(i);
                int xi = (int) (pt.x * 10.0);
                int yi = (int) (pt.y * 10.0);
                bb.putInt(xi);
                bb.putInt(yi);
            }
            double endAngle = Math.toRadians(segeangle / 100.0);
            if (speed_mm_s < 0) {
                endAngle += Math.PI;
            }
            double se = Math.sin(endAngle);
            double ce = Math.cos(endAngle);
            if (crab) {

                se = diffu.y;
                ce = diffu.x;
            }
            this.last_three_pts_sent[0] = segex - (int) (ce * end_seg);
            bb.putInt(this.last_three_pts_sent[0]);
            this.last_three_pts_sent[1] = segey - (int) (se * end_seg);
            bb.putInt(this.last_three_pts_sent[1]);
//            System.out.println("bb = " + bb);
            this.last_three_pts_sent[2] = segex;
            bb.putInt(this.last_three_pts_sent[2]);
            this.last_three_pts_sent[3] = segey;
            bb.putInt(this.last_three_pts_sent[3]);
            this.last_three_pts_sent[4] = segex + (int) (ce * end_seg);
            bb.putInt(this.last_three_pts_sent[4]);
            this.last_three_pts_sent[5] = segey + (int) (se * end_seg);
            bb.putInt(this.last_three_pts_sent[5]);

            byte ba[] = bb.array();
            final byte[] final_ba = ba;
            final OutputStream final_os = os;
            final JFrame frm = this;
            if (debugVehicleComm) {
                System.out.println("bb = " + bb);
                System.out.println("bb.position() = " + bb.position());
                System.out.println("ba = " + ba);
                System.out.println("ba:");
                printByteArray(ba);
                System.out.println("");
                System.out.println("ba.length = " + ba.length);
                System.out.println("bbsz = " + bbsz);
            }
            if (this.jCheckBoxMenuItemConfirmControlPoints.isSelected()) {
                final LinkedBlockingQueue<Integer> q = new LinkedBlockingQueue<>();
                java.awt.EventQueue.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        splinePanel1.updatePlannerInfo(csStart, csEnd, planner_list, cntrlPts);
                        int result = JOptionPane.showConfirmDialog(frm, "Send Control Points?", frm.getTitle() + ": Send control points?",
                                JOptionPane.YES_NO_OPTION);
                        boolean put_done = false;
                        while (!put_done) {
                            try {
                                q.put(result);
                                put_done = true;
                            } catch (InterruptedException interruptedException) {
                            }
                        }
                    }
                });
                if (q.take() != JOptionPane.YES_OPTION) {
                    if (this.splinePanel1.getGoalSource() == GoalSourceEnum.MANUAL) {
                        this.splinePanel1.setGoalPoints(null);
                    }
                    return false;
                }
            }
            os.write(ba);
            this.last_cntrl_pts_sent_ba = ba;
            if (debugVehicleComm) {
                System.out.println("sendControlPoints Sent:");
                printByteArray(ba);
                System.out.println("");
            }
            if (this.splinePanel1.isPlotAllCtrlPtsSent()) {
                this.plotLastCntrlPtsSent();
            }
            byte h4[] = new byte[4];
            InputStream is = socket.getInputStream();
            bb = ByteBuffer.wrap(h4);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            is.read(h4);
            short type = bb.getShort();
            if (debugVehicleComm) {
                System.out.printf("sendControlPoints response type = 0x%X\n", type);
            }
            short sz = bb.getShort();
            if (debugVehicleComm) {
                System.out.println("sendControlPoints response sz = " + sz);
            }
            if (sz < 4) {
                throw new RuntimeException("Bad size value of " + sz);
            }
            ba = new byte[sz - 4];
            is.read(ba);
            if (debugVehicleComm) {
                System.out.println("sendControlPoints response:");
                printByteArray(ba);
                System.out.println("");
            }

            bb = ByteBuffer.wrap(ba);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            switch (type) {
                case 0x61:
                    short returnvalue = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("returnvalue = " + returnvalue);
                    }
                    short state = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("state = " + state);
                    }
                    setStatusLabel(returnvalue, state, segi);
                    if (returnvalue == 1) {
                        return true;
                    }
                    if (returnvalue == 0) {
                        return true;
                    }
                    System.out.println("sendControlPoints response: return value = " + returnvalue + ", state=" + state);
                    break;
            }
            return false;
        } catch (Exception e) {
            System.err.println("bb=" + bb);
            e.printStackTrace();
        }
        return false;
    }

    public void MonitorVehicle() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                if (CheckVehicle()) {
                    return;
                }
                Thread.sleep(500);
                if (null == monitorVehicleThread) {
                    return;
                }
                if (monitorVehicleThread.isInterrupted()) {
                    return;
                }
            }
        } catch (InterruptedException interruptedException) {
//            interruptedException.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public void saveSplinePoints(List<? extends Point2Dd> l) {
        try {
            File spline_dir_f = new File(System.getProperty("user.home"), "saved_splines");
            spline_dir_f.mkdirs();
            DateFormat df = DateFormat.getDateTimeInstance();
            String now = df.format(new Date()).trim().replace(' ', '_').replace(',', '_').replace(':', '_').replace('/', ' ').replace('\\', '_').replace('.', '_');
            File spline_save_file = new File(spline_dir_f, "saved_spline_" + now + ".csv");
            PrintStream ps = new PrintStream(new FileOutputStream(spline_save_file, true));
            ps.println("x,y");
            for (Point2Dd pt : l) {
                ps.println(pt.x + "," + pt.y);
            }
            ps.close();
            System.out.println("Saved : " + spline_save_file.getCanonicalPath());
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }

    public void saveControlPoints(List<? extends Point2Dd> l) {
        try {
            if (null == l || l.size() < 1) {
                return;
            }
            File spline_dir_f = new File(System.getProperty("user.home"), "saved_control_pts");
            spline_dir_f.mkdirs();
            DateFormat df = DateFormat.getDateTimeInstance();
            String now = df.format(new Date()).trim().replace(' ', '_').replace(',', '_').replace(':', '_').replace('/', ' ').replace('\\', '_').replace('.', '_');
            File spline_save_file = new File(spline_dir_f, "saved_control_pts_" + now + ".csv");
            PrintStream ps = new PrintStream(new FileOutputStream(spline_save_file, true));
            ps.println("x,y");
            for (Point2Dd pt : l) {
                ps.println(pt.x + "," + pt.y);
            }
            ps.close();
            System.out.println("Saved : " + spline_save_file.getCanonicalPath());
        } catch (Exception exception) {
            exception.printStackTrace();
        }
    }
    public boolean debugVehicleComm = false;
    int last_three_pts_sent[] = new int[6];
    short last_sent_seg_id = -1;
    int lastreturnvalue = -1;
    int laststate = -1;
    int lastsegid = -1;

    public void setStatusLabel(int returnvalue, int state, int segid) {
        if (returnvalue == lastreturnvalue && state == laststate && segid == lastsegid) {
            return;
        }
        String s = "Vehicle Status : ";
        switch (returnvalue) {
            case 0:
                break;
            case 1:
                s += " Spline command accepted ";
                break;

            case 2:
                s += " Wrong State ";
                break;

            case 3:
                s += " spline error ";
                break;

            default:
                s += " unrecognized return value = " + returnvalue;
                break;
        }
        switch (state) {
            case 0:
                s += " state=Idle ";
                break;

            case 1:
                s += " state=\"Waiting for external command.\" ";
                break;

            case 2:
                s += " state=\"External command received.\" ";
                break;

            default:
                s += " unrecognized state value = " + state;
                break;
        }
        s += " segid=" + segid;
        s += " count=" + this.sendControlPointsCount;
        this.jLabelVehicleStatus.setText(s);
        this.lastreturnvalue = returnvalue;
        this.laststate = state;
        this.lastsegid = segid;
    }
    int lastGoalId = -1;

    private static CarrierState cs0 = null;
    CarrierState unsentGoal = null;
    boolean checking_vehicle = false;

    public boolean CheckVehicle() throws InterruptedException {
        ByteBuffer bb = null;
        byte ba[] = null;
        byte h4[] = null;
        int segsx = 0;
        int segsy = 0;
        double sangle = 0.0;
        double vehicle_width = this.splinePanel1.getVehicleWidth();
        double vehicle_front = this.splinePanel1.getVehicleFront();
        double vehicle_back = this.splinePanel1.getVehicleBack();
        double planner_point_size = this.splinePanel1.getPlannerPointDisplaySize();
        try {

            this.splinePanel1.setMaxCntrlPts(15);
            debugVehicleComm = this.splinePanel1.isDebugVehicleComm();
            this.reconnect();
            this.splinePanel1.incrementDelayReplanCount();
            Socket s = this.socket_to_vehicle;
            OutputStream os = s.getOutputStream();
            InputStream is = s.getInputStream();
            bb = ByteBuffer.allocate(8);
            ba = bb.array();
            bb.order(ByteOrder.LITTLE_ENDIAN);
            bb.putShort((short) 0x64);
            bb.putShort((short) 8);
            ba = bb.array();
            os.write(bb.array());
            if (debugVehicleComm) {
                System.out.println("Sent:");
                printByteArray(ba);
                System.out.println("");
            }
            h4 = new byte[4];
            bb = ByteBuffer.wrap(h4);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            is.read(h4);
            short type = bb.getShort();
            if (debugVehicleComm) {
                System.out.printf("type = 0x%X\n", type);
            }
            short sz = bb.getShort();
            if (debugVehicleComm) {
                System.out.println("sz = " + sz);
            }
            if (sz < 4) {
                throw new RuntimeException("Bad size value of " + sz);
            }
            ba = new byte[sz - 4];
            is.read(ba);
            bb = ByteBuffer.wrap(ba);
            bb.order(ByteOrder.LITTLE_ENDIAN);
            switch (type) {
                case 0x61:
                    short returnvalue = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("returnvalue = " + returnvalue);
                    }
                    short state = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("state = " + state);
                    }

                    if (sz <= 8) {
                        System.out.println("returnvalue = " + returnvalue);
                        System.out.println("state = " + state);
                        System.out.println("response size too small quitting");
                        break;
                    }
                    if (debugVehicleComm) {
                        System.out.println("Recvd:");
                        printByteArray(h4);
                        printByteArray(ba);
                        System.out.println("");

                    }
                    short segi = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("segi = " + segi);
                    }
                    if (state != 1 || segi == last_sent_seg_id) {
                        setStatusLabel(returnvalue, state, segi);
                        break;
                    }
                    bb.getShort(); // spare
                    segsx = bb.getInt();
                    if (debugVehicleComm) {
                        System.out.println("segsx = " + segsx);
                    }
                    segsy = bb.getInt();
                    if (debugVehicleComm) {
                        System.out.println("segsy = " + segsy);
                    }
                    short segsangle = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("segsangle = " + segsangle);
                    }
                    bb.getShort();
                    int segex = bb.getInt();
                    if (debugVehicleComm) {
                        System.out.println("segex = " + segex);
                    }
                    //bb.getShort();
                    int segey = ((short) (bb.getInt()));
                    if (debugVehicleComm) {
                        System.out.println("segey = " + segey);
                    }
//                        System.out.println("segey = " + segey);
                    //bb.getShort();
                    short segeangle = bb.getShort();
                    if (debugVehicleComm) {
                        System.out.println("segeangle = " + segeangle);
                    }
                    sangle = Math.toRadians(segsangle / 100.0);
                    double eangle = Math.toRadians(segeangle / 100.0);
                    PlannerInput pi = new PlannerInput();
                    pi.segStartLength = this.splinePanel1.getSegStartLength();
                    pi.reverse = this.splinePanel1.isReverse();
                    if (null == cs0 || Math.abs(cs0.x - segsx / 10.0) > 1.0 || Math.abs(cs0.y - segsy / 10.0) > 1.0
                            || Math.abs(cs0.getAngle().getValue() - Math.toRadians(segsangle / 100.0)) > 0.1) {
                        cs0 = new CarrierState(segsx / 10.0,
                                segsy / 10.0,
                                new AngleD(Math.toRadians(segsangle / 100.0)),
                                CarrierStateTypeEnum.START,
                                planner_point_size,
                                vehicle_width,
                                vehicle_front,
                                vehicle_back);
                    }
                    CarrierState nextGoal = null;
                    GoalSourceEnum goalSource = this.splinePanel1.getGoalSource();
                    pi.crab = this.splinePanel1.isCrab();
                    if (goalSource == GoalSourceEnum.MANUAL) {
                        if (pi.crab) {
                            this.splinePanel1.setStartingAngle(Math.toDegrees(cs0.getAngle().getValue()));
                            this.updateAngle();
                        }
                        splinePanel1.setGoalPoints(null);
                        splinePanel1.updatePlannerInfo(cs0, this.unsentGoal, null, null);
                        this.jButtonSendManualGoal.setEnabled(true);
                        int goal_count = this.manualGoalBlockingQueue.take();
                        checking_vehicle = true;
                        pi.segStartLength = this.splinePanel1.getSegStartLength();
                        pi.reverse = this.splinePanel1.isReverse();
                        pi.crab = this.splinePanel1.isCrab();
                        this.jButtonSendManualGoal.setEnabled(false);
                        List<CarrierState> goalPoints = this.splinePanel1.getGoalPoints();
                        if (goalPoints == null || goalPoints.size() < 1) {
                            if (debugVehicleComm) {
                                System.out.println("No manually set goal point");
                            }
                            setStatusLabel(returnvalue, state, segi);
                            java.awt.EventQueue.invokeLater(new Runnable() {
                                @Override
                                public void run() {
                                    splinePanel1.updatePlannerInfo(cs0, null, null, null);
                                }
                            });
                            break;
                        } else {
                            checking_vehicle = true;
                            CarrierState curGoal = goalPoints.get(0);
                            if (null == curGoal) {
                                if (debugVehicleComm) {
                                    System.out.println("null == curGoal");
                                }
                                setStatusLabel(returnvalue, state, segi);

                                java.awt.EventQueue.invokeLater(new Runnable() {
                                    @Override
                                    public void run() {
                                        splinePanel1.updatePlannerInfo(cs0, null, null, null);
                                    }
                                });
                                break;
                            } else if (curGoal.getId() == this.lastGoalId) {
                                if (debugVehicleComm) {
                                    System.out.println("curGoal.getId() (" + curGoal.getId() + ") == lastGoalId");
                                }
                                setStatusLabel(returnvalue, state, segi);
                                curGoal = null;
                                java.awt.EventQueue.invokeLater(new Runnable() {
                                    @Override
                                    public void run() {
                                        splinePanel1.updatePlannerInfo(cs0, null, null, null);
                                    }
                                });
                                break;
                            } else {
                                segex = (short) (curGoal.x * 10.0);
                                segey = (short) (curGoal.y * 10.0);

                                segeangle = (short) (Math.toDegrees(curGoal.getAngle().getValue()) * 100.0);
                                if (curGoal.isReverse()) {
                                    segeangle = (short) ((segeangle + 18000) % 36000);
                                }
                                eangle = Math.toRadians(segeangle / 100.0);
                                nextGoal = curGoal;
                            }
                        }
                    } else if (goalSource == GoalSourceEnum.WAYPOINTS) {
                        double min_dist = Double.POSITIVE_INFINITY;
                        CarrierState closestStartPt = null;
//                        List<CarrierState> startPoints = this.splinePanel1.getStartPoints();
//                        for (CarrierState sp : startPoints) {
//                            if (null != sp.getGoal()) {
//                                double dist = sp.distance(cs0) + Planner.chord(sp.unit(), cs0.unit(),
//                                        this.splinePanel1.getMinTurnRadius() + this.splinePanel1.getPlannerResolution());
//                                if (dist < min_dist) {
//                                    closestStartPt = sp;
//                                    min_dist = dist;
//                                }
//                            }
//                        }
                        List<CarrierState> waypoints = this.splinePanel1.getWaypoints();
                        for (CarrierState wp : waypoints) {
                            if (null != wp.getGoal()) {
                                double dist = wp.distance(cs0) + Planner.chord(wp.unit(), cs0.unit(),
                                        this.splinePanel1.getMinTurnRadius() + this.splinePanel1.getPlannerResolution());
                                if (dist < min_dist) {
                                    closestStartPt = wp;
                                    min_dist = dist;
                                }
                            }
                        }
                        if (null != closestStartPt) {
                            CarrierState curGoal = closestStartPt.getGoal();
                            segex = (short) (curGoal.x * 10.0);
                            segey = (short) (curGoal.y * 10.0);
                            segeangle = (short) (Math.toDegrees(curGoal.getAngle().getValue()) * 100.0);
                            eangle = Math.toRadians(segeangle / 100.0);
                        }
                    }
                    Point2Dd spt = new Point2Dd(segsx / 10.0, segsy / 10.0);
                    Point2Dd ept = new Point2Dd(segex / 10.0, segey / 10.0);
                    Point2Dd end_to_start = ept.diff(spt);
                    if (!pi.crab && goalSource != GoalSourceEnum.MANUAL) {
                        Point2Dd start_vecu = new Point2Dd(Math.cos(sangle), Math.sin(sangle));
                        Point2Dd end_vecu = new Point2Dd(Math.cos(eangle), Math.sin(eangle));
                        Point2Dd end_to_startu = end_to_start.unit();
                        if (!pi.reverse && start_vecu.dot(end_to_startu) < -0.01 && end_vecu.dot(end_to_startu) < -0.01) {
                            this.splinePanel1.setReverse(true);
                            this.jCheckBoxReverse.setSelected(true);
                            pi.reverse = true;
                        } else if (pi.reverse && start_vecu.dot(end_to_startu) > 0.01 && end_vecu.dot(end_to_startu) > 0.01) {
                            this.splinePanel1.setReverse(false);
                            this.jCheckBoxReverse.setSelected(false);
                            pi.reverse = false;
                        }
                    }
                    if (pi.crab) {
                        sangle = Math.atan2(end_to_start.y, end_to_start.x);
                    }
                    final CarrierState csStart = cs0;
//                    new CarrierState(segsx / 10.0 /* + segStartLength * Math.cos(sangle) */,
//                            segsy / 10.0 /* + segStartLength * Math.sin(sangle) */,
//                            new AngleD(Math.toRadians(segsangle / 100.0)),
//                            CarrierStateTypeEnum.START,
//                            planner_point_size,
//                            vehicle_width,
//                            vehicle_front,
//                            vehicle_back);

                    if (pi.crab) {
                        eangle = Math.atan2(end_to_start.y, end_to_start.y);
                    }
                    if (nextGoal == null) {
                        nextGoal = new CarrierState(segex / 10.0 /* - segStartLength * Math.cos(eangle) */,
                                segey / 10.0 /* - segStartLength * Math.sin(eangle) */,
                                new AngleD(Math.toRadians(segeangle / 100.0)),
                                CarrierStateTypeEnum.GOAL,
                                planner_point_size,
                                vehicle_width,
                                vehicle_front,
                                vehicle_back);
                    }
                    final CarrierState csEnd = nextGoal;
                    csStart.setGoal(csEnd);
                    Point2Dd goalToLastGoal = null;
                    if (null != lastGoal) {
                        goalToLastGoal = csEnd.diff(lastGoal);
                    }
                    if (goalSource == GoalSourceEnum.MANUAL && end_to_start.mag() < 10.0) {
                        if (debugVehicleComm) {
                            System.out.println("end_to_start.mag() = " + end_to_start.mag());
                        }
                        setStatusLabel(returnvalue, state, segi);
                        java.awt.EventQueue.invokeLater(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(csStart, null, null, null);
                            }
                        });
                        break;
                    }
                    if (goalSource == GoalSourceEnum.MANUAL && goalToLastGoal != null && goalToLastGoal.mag() < 10.0) {
                        if (debugVehicleComm) {
                            System.out.println("startToLastGoal = " + goalToLastGoal);
                            System.out.println("startToLastGoal.mag() = " + end_to_start.mag());
                        }
                        setStatusLabel(returnvalue, state, segi);
                        java.awt.EventQueue.invokeLater(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(cs0, null, null, null);
                            }
                        });
                        break;
                    }

                    pi.back = vehicle_back;
                    pi.front = vehicle_front;
                    if (this.splinePanel1.isIgnoreBoundaries()) {
                        pi.boundaries = null;
                    } else {
                        pi.boundaries = this.splinePanel1.getBoundaries();
                    }
                    pi.obstacles = this.splinePanel1.getObstacles();
                    pi.crab = this.splinePanel1.isCrab();

                    pi.goal = csEnd;
                    pi.start = csStart;
                    pi.path_uncertainty = this.splinePanel1.getPathUncertainty();
                    pi.veh_width = this.splinePanel1.getVehicleWidth();
                    pi.max_pt2pt_dist = this.splinePanel1.getMax_pt2pt_dist();
                    pi.plannerResolution = this.splinePanel1.getPlannerResolution();
                    pi.max_cntrl_pts = this.splinePanel1.getMaxCntrlPts();
                    pi.min_turn_radius = this.splinePanel1.getMinTurnRadius();
                    pi.max_turn_angle_degrees = this.splinePanel1.getMaxTurnAngleDegrees();
                    pi.planningHorizon = this.splinePanel1.getPlanningHorizon();
                    double start_to_goal_dist = pi.start.distance(pi.goal);
                    if (pi.max_pt2pt_dist < start_to_goal_dist / 7.0) {
                        pi.max_pt2pt_dist = start_to_goal_dist / 7.0;
                        System.out.println("pi.max_pt2pt_dist = " + pi.max_pt2pt_dist);
                        this.splinePanel1.setMaxCntrlPts(pi.max_cntrl_pts);
                    }
                    List<PlannerPoint> tmp_cntrlPts = null;
                    List<PlannerPoint> tmp_planner_list = null;
                    if (csStart.getPath() != null
                            && csStart.getPath().getControlPoints() != null
                            && csStart.getPlannerList() != null) {
                        tmp_cntrlPts = csStart.getPath().getControlPoints();
                        tmp_planner_list = csStart.getPlannerList();
                    } else {
                        java.awt.EventQueue.invokeAndWait(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(csStart, csEnd, null, null);
                            }
                        });
                        tmp_planner_list = Planner.createPlannerList(pi, splinePanel1.getStartPoints(), splinePanel1.getGoalPoints(), splinePanel1.getWaypoints());
                        tmp_cntrlPts = Planner.planWithPlannerList(pi, tmp_planner_list);
                    }
                    final List<PlannerPoint> cntrlPts = tmp_cntrlPts;
                    final List<PlannerPoint> planner_list = tmp_planner_list;
                    boolean sendCtrlPtsOk = false;
                    if (null != cntrlPts && cntrlPts.size() > 0) {
                        short speed_mm_s = (short) (10.0 * this.splinePanel1.getSpeed());
                        if (pi.reverse && !pi.crab) {
                            speed_mm_s = (short) (-1 * speed_mm_s);
                        }
                        sendCtrlPtsOk
                                = sendCtrlPtsOk = sendControlPoints(s, csStart,
                                        csEnd,
                                        cntrlPts,
                                        planner_list,
                                        pi.crab,
                                        segsx, segsy, segsangle,
                                        segex, segey, segeangle,
                                        segi,
                                        speed_mm_s);
                    } else {
                        this.splinePanel1.setGoalPoints(null);
                    }
                    os.close();
                    is.close();
                    s.close();
                    this.socket_to_vehicle.close();
                    this.socket_to_vehicle = null;
                    final JFrame jf = this;
                    if (sendCtrlPtsOk) {
                        last_sent_seg_id = segi;
                        saveControlPoints(cntrlPts);
                        saveSplinePoints(BSplineCreator.createBSpline(
                                this.splinePanel1.getMinCurveIterations(),
                                this.splinePanel1.getMaxCurveIterations(),
                                this.splinePanel1.getCurveIterationDist(),
                                cntrlPts));
                        lastGoal = new Point2Dd(csEnd.x, csEnd.y);
                        lastGoalId = csEnd.getId();
                        java.awt.EventQueue.invokeAndWait(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(csStart, csEnd, planner_list, cntrlPts);
                            }
                        });
                        this.unsentGoal = null;
                    }
                    checking_vehicle = false;
                    if (null == cntrlPts || cntrlPts.size() < 1) {
                        final String sm = "Goal is not reachable. " + csEnd + " from " + csStart + ":retry?";
                        System.out.println(sm);
                        java.awt.EventQueue.invokeAndWait(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(csStart, csEnd, null, null);
                                boolean result = ask(sm);
                                if (!result) {
                                    DisconnectFromVehicle();
                                }
                            }
                        });
                        this.unsentGoal = csEnd;
                    } else if (!sendCtrlPtsOk) {
                        final String sm = "Failed trying to send control points " + csEnd + " from " + csStart + ":retry?";
                        System.out.println(sm);
                        java.awt.EventQueue.invokeAndWait(new Runnable() {
                            @Override
                            public void run() {
                                splinePanel1.updatePlannerInfo(csStart, csEnd, null, null);
                                boolean result = ask(sm);
                                if (!result) {
                                    DisconnectFromVehicle();
                                }
                            }
                        });
                        this.unsentGoal = csEnd;
                    }
                    return false;

                case 0x65:
                    System.err.println("Error message recieved.");
                    this.DisconnectFromVehicle();
                    this.jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
                    break;

                default:
                    System.err.println("Unrecognized message type:" + type);
                    break;
            }
        } catch (InterruptedException ie) {
            throw ie;
        } catch (Exception e) {
            System.err.println("bb=" + bb);
            e.printStackTrace();
            final Component c = this;
            final String s = e.getMessage();
            if (null != ba) {
                System.out.println("ba:");
                printByteArray(ba);
            }
            if (null != h4) {
                System.out.println("h4:");
                printByteArray(h4);
            }
            java.awt.EventQueue.invokeLater(new Runnable() {
                @Override
                public void run() {
                    DisconnectFromVehicle();
                    if (ask(s + " :  Retry?")) {
                        if (splinePanel1.getGoalSource() == GoalSourceEnum.MANUAL) {
                            if (ask("Clear manual goal?")) {
                                splinePanel1.updatePlannerInfo(cs0, null, null, null);
                            }
                        }
                        ConnectToVehicle();
                    }
                }
            });
        }
        this.splinePanel1.decrementDelayReplanCount();
        return false;
    }

    public boolean ask(final String query) {
        return (JOptionPane.showConfirmDialog(this, query, this.getTitle() + " : " + query, JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION);
    }
    SocketAddress vehicleAddress = new InetSocketAddress("192.168.160.3", 4000);

    private void reconnect() throws Exception {
        if (null != this.socket_to_vehicle
                && this.socket_to_vehicle.isConnected()) {
            return;
        }
        this.socket_to_vehicle = new Socket();
        this.socket_to_vehicle.setReuseAddress(true);
        this.socket_to_vehicle.setSoTimeout(0);
        Thread.sleep(1000);
        this.socket_to_vehicle.connect(vehicleAddress,
                5000);
    }

    public void ConnectToVehicle() {
        try {
            this.updateAngle();
            this.last_sent_seg_id = -1;
            this.lastsegid = -1;
//            this.jCheckBoxMenuItemReplanOnAllChanges.setSelected(false);
//            this.jCheckBoxMenuItemReplanOnAllChanges.setEnabled(false);
//            this.splinePanel1.setReplanOnAllChanges(false);
            this.splinePanel1.setConnectedToVehicle(true);
            sendControlPointsCount = 0;
            this.jRadioButtonStart.setEnabled(false);
            if (!(this.splinePanel1.getGoalSource() == GoalSourceEnum.MANUAL)) {
                this.jRadioButtonGoal.setEnabled(false);
                this.jRadioButtonPan.setSelected(true);
                this.splinePanel1.setDrawMode(SplineDrawMode.PAN);
            } else {
                this.jRadioButtonGoal.setEnabled(true);
                this.jRadioButtonGoal.setSelected(true);
                this.splinePanel1.setDrawMode(SplineDrawMode.GOAL);
            }

            this.reconnect();
            if (null == this.socket_to_vehicle || !this.socket_to_vehicle.isConnected()) {
                JOptionPane.showMessageDialog(this, "ConnectToVehicle Failed!");
                this.DisconnectFromVehicle();
                return;
            }
            monitorVehicleThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    MonitorVehicle();
                }
            }, "monitorVehicleThread");
            monitorVehicleThread.start();
            if (!this.jCheckBoxMenuItemConnectedToVehicle.isSelected()) {
                this.jCheckBoxMenuItemConnectedToVehicle.setSelected(true);
            }
        } catch (Exception e) {
            e.printStackTrace();
            JOptionPane.showMessageDialog(this, "ConnectToVehicle Failed!");
            this.DisconnectFromVehicle();
        }
    }

    public void DisconnectFromVehicle() {
        try {
//            this.jCheckBoxMenuItemReplanOnAllChanges.setEnabled(true);
            this.jRadioButtonStart.setEnabled(true);
            this.jRadioButtonGoal.setEnabled(true);
            sendControlPointsCount = 0;
            if (null != this.socket_to_vehicle) {
                this.socket_to_vehicle.close();
                this.socket_to_vehicle = null;
            }
            if (null != this.monitorVehicleThread) {
                this.monitorVehicleThread.interrupt();
                this.monitorVehicleThread.join(5000);
                this.monitorVehicleThread = null;
            }
            if (this.jCheckBoxMenuItemConnectedToVehicle.isSelected()) {
                this.jCheckBoxMenuItemConnectedToVehicle.setSelected(false);
            }
            this.splinePanel1.setConnectedToVehicle(false);
            this.updateAngle();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public final void centerDrawPanelViewPort() {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension pref_size = this.splinePanel1.getPreferredSize();
        int center_x = pref_size.width / 2;
        int center_y = pref_size.height / 2;
        Point new_upper_corner = new Point((int) (center_x - rect.width / 2),
                ((int) center_y - rect.height / 2));
        if (new_upper_corner.x < 0) {
            new_upper_corner.x = 0;
        }
        if (new_upper_corner.y < 0) {
            new_upper_corner.y = 0;
        }
        vp.setViewPosition(new_upper_corner);
    }

    public void changeZoom(double scale) {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension old_pref_size = this.splinePanel1.getPreferredSize();
        Dimension new_pref_size = new Dimension(
                (int) Math.max(rect.width, old_pref_size.width * scale),
                (int) Math.max(rect.height, old_pref_size.height * scale));
        this.splinePanel1.setPreferredSize(new_pref_size);
        this.splinePanel1.revalidate();
        this.jScrollPane1.revalidate();
        this.splinePanel1.setZoomScale(this.splinePanel1.getZoomScale() * scale);
        this.repaint();
    }

    /**
     * After zooming or fitting update the JScrollPane's viewport.
     */
    public final void updateDrawPanelViewport(double scale) {
        JViewport vp = this.jScrollPane1.getViewport();
        Rectangle rect = vp.getViewRect();
        Dimension d = new Dimension();
        d.width = (int) (rect.width * scale);
        d.height = (int) (rect.height * scale);
        Dimension old_pref_size = this.splinePanel1.getPreferredSize();
        this.splinePanel1.setPreferredSize(d);
        this.splinePanel1.setZoomScale((float) scale);
        this.splinePanel1.revalidate();
        this.jScrollPane1.revalidate();
        this.repaint();
        double old_center_x = rect.x + rect.width / 2;
        double old_center_y = rect.y + rect.height / 2;
        double center_x = old_center_x * d.width / ((double) old_pref_size.width);
        double center_y = old_center_y * d.height / ((double) old_pref_size.height);
        Point new_upper_corner = new Point((int) (center_x - rect.width / 2),
                ((int) center_y - rect.height / 2));
        if (new_upper_corner.x < 0) {
            this.splinePanel1.setTranslateX(new_upper_corner.x * this.splinePanel1.getZoomScale());
            new_upper_corner.x = 0;
        } else {
            this.splinePanel1.setTranslateX(0);
        }
        if (new_upper_corner.y < 0) {
            this.splinePanel1.setTranslateY(new_upper_corner.y * this.splinePanel1.getZoomScale());
            new_upper_corner.y = 0;
        } else {
            this.splinePanel1.setTranslateY(0);
        }
        vp.setViewPosition(new_upper_corner);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(SplineTestJFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SplineTestJFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.ButtonGroup buttonGroupDrawMode;
    private javax.swing.ButtonGroup buttonGroupGoalSource;
    private javax.swing.JButton jButtonClear;
    private javax.swing.JButton jButtonDelete;
    private javax.swing.JButton jButtonDown;
    private javax.swing.JButton jButtonFit;
    private javax.swing.JButton jButtonLeft;
    private javax.swing.JButton jButtonModifyAngle;
    private javax.swing.JButton jButtonRight;
    private javax.swing.JButton jButtonSendManualGoal;
    private javax.swing.JButton jButtonUp;
    private javax.swing.JButton jButtonZoomLess;
    private javax.swing.JButton jButtonZoomMore;
    private javax.swing.JCheckBox jCheckBoxCrab;
    private javax.swing.JCheckBox jCheckBoxExclusiveTracks;
    private javax.swing.JCheckBox jCheckBoxIgnoreBoundaries;
    private javax.swing.JCheckBox jCheckBoxLabelControlPoints;
    private javax.swing.JCheckBox jCheckBoxLabelGrid;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemConfirmControlPoints;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemConnectToObsDetect;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemConnectedToVehicle;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemDebugObsDetComm;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemDebugVehicleComm;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemPlotAllCntlrPts;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemRecordPlannerStats;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemReplanOnAllChanges;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemShowBackground;
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemStaticPlannerList;
    private javax.swing.JCheckBox jCheckBoxReverse;
    private javax.swing.JCheckBox jCheckBoxShowCenterCurve;
    private javax.swing.JCheckBox jCheckBoxShowControlPath;
    private javax.swing.JCheckBox jCheckBoxShowGrid;
    private javax.swing.JCheckBox jCheckBoxShowOutlines;
    private javax.swing.JCheckBox jCheckBoxShowPlanOutline;
    private javax.swing.JCheckBox jCheckBoxShowPlanning;
    private javax.swing.JCheckBox jCheckBoxShowSideCurves;
    private javax.swing.JCheckBox jCheckBoxSimulation;
    private javax.swing.JLabel jLabelAngle;
    private javax.swing.JLabel jLabelPlannerStatus;
    private javax.swing.JLabel jLabelVehicleStatus;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenu jMenuBackground;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenu jMenuChecks;
    private javax.swing.JMenu jMenuConnections;
    private javax.swing.JMenu jMenuImport;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenuItem jMenuItemChangeFields;
    private javax.swing.JMenuItem jMenuItemClear;
    private javax.swing.JMenuItem jMenuItemDelete;
    private javax.swing.JMenuItem jMenuItemDown;
    private javax.swing.JMenuItem jMenuItemFileOpen;
    private javax.swing.JMenuItem jMenuItemFileSaveAs;
    private javax.swing.JMenuItem jMenuItemForceReplanning;
    private javax.swing.JMenuItem jMenuItemImportDXFBackground;
    private javax.swing.JMenuItem jMenuItemImportDXFBoundaries;
    private javax.swing.JMenuItem jMenuItemLeft;
    private javax.swing.JMenuItem jMenuItemPlotCurveRadius;
    private javax.swing.JMenuItem jMenuItemPlotLastCntrlPtsSent;
    private javax.swing.JMenuItem jMenuItemPlotRecordedPlannerStats;
    private javax.swing.JMenuItem jMenuItemPlotSplinesWithControlPoints;
    private javax.swing.JMenuItem jMenuItemReCheckPath;
    private javax.swing.JMenuItem jMenuItemRight;
    private javax.swing.JMenuItem jMenuItemSetProperty;
    private javax.swing.JMenuItem jMenuItemSwapGoalStart;
    private javax.swing.JMenuItem jMenuItemTestAllPositons;
    private javax.swing.JMenuItem jMenuItemTestPlanningParam;
    private javax.swing.JMenuItem jMenuItemUp;
    private javax.swing.JMenu jMenuMove;
    private javax.swing.JMenu jMenuOptions;
    private javax.swing.JMenu jMenuRecentFiles;
    private javax.swing.JRadioButton jRadioButtonBoundary;
    private javax.swing.JRadioButton jRadioButtonDrawPlanningRect;
    private javax.swing.JRadioButton jRadioButtonGoal;
    private javax.swing.JRadioButton jRadioButtonHorzBoundary;
    private javax.swing.JRadioButtonMenuItem jRadioButtonMenuItemGoalFromConnection;
    private javax.swing.JRadioButtonMenuItem jRadioButtonMenuItemGoalFromWaypoints;
    private javax.swing.JRadioButtonMenuItem jRadioButtonMenuItemManualGoal;
    private javax.swing.JRadioButton jRadioButtonObstacle;
    private javax.swing.JRadioButton jRadioButtonPan;
    private javax.swing.JRadioButton jRadioButtonSelect;
    private javax.swing.JRadioButton jRadioButtonStart;
    private javax.swing.JRadioButton jRadioButtonVertBoundary;
    private javax.swing.JRadioButton jRadioButtonWaypoint;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JToolBar.Separator jSeparator1;
    private javax.swing.JToolBar.Separator jSeparator2;
    private javax.swing.JSeparator jSeparator3;
    private javax.swing.JPopupMenu.Separator jSeparator4;
    private javax.swing.JToolBar jToolBar1;
    private javax.swing.JToolBar jToolBar2;
    private javax.swing.JToolBar jToolBar3;
    private splinetest.SplinePanel splinePanel1;
    // End of variables declaration//GEN-END:variables
}
